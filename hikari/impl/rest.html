<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.impl.rest API documentation</title>
<meta name="description" content="Implementation of a V6 and V7 compatible HTTP API for Discord …" />
<meta property="og:title" content="hikari.impl.rest module documentation" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://nekokatt.github.io/hikari/logo.png" />
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions" />
<meta property="theme-color" content="#ff029a" />
<link rel="shortcut icon" type="image/png" href="https://nekokatt.github.io/hikari/logo.png"/>
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet"/>
<style>
* {
scrollbar-color: #202324 #454a4d;
scroll-behavior: smooth;
}
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
}
small.smaller {
font-size: 0.75em;
}
body {
background-color: #181A1B;
color: #C9C5C0;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<!-- body.mako -->
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/nekokatt/hikari"><img class="d-inline-block align-top" src="https://nekokatt.github.io/hikari/logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small>v2.0.0.dev82</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/hikari/index.html">Home</a></li>
<li class="nav-item active"><a class="nav-link" href="/hikari/hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/nekokatt/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" >
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
class='dotted'>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.impl -- Basic implementations of application components …" href="index.html"
class='dotted'>impl</a></li>
<li class="breadcrumb-item active"><a href="#">rest</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Implementation of a V6 and V7 compatible HTTP API for Discord.</p>
<p>This also includes implementations designed towards providing
RESTful functionality.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="BasicLazyCachedTCPConnectorFactory -- Lazy cached TCP connector factory." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory"
class='sidebar-nav-pill'>BasicLazyCachedTCPConnectorFactory</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="acquire -- Acquire the connector." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.acquire"
class='sidebar-nav-pill'>acquire</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Close any resources if they exist." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.close"
class='sidebar-nav-pill'>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="connector -- Return an attribute of instance, which is of type owner." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.connector"
class='sidebar-nav-pill'>connector</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return an attribute of instance, which is of type owner." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.http_settings"
class='sidebar-nav-pill'>http_settings</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTApp -- The base for a HTTP-only Discord application …" href="#hikari.impl.rest.RESTApp"
class='sidebar-nav-pill'>RESTApp</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="acquire -- " href="#hikari.impl.rest.RESTApp.acquire"
class='sidebar-nav-pill'>acquire</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- " href="#hikari.impl.rest.RESTApp.close"
class='sidebar-nav-pill'>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="executor -- Return the executor to use for blocking operations …" href="#hikari.impl.rest.RESTApp.executor"
class='sidebar-nav-pill'>executor</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- " href="#hikari.impl.rest.RESTApp.http_settings"
class='sidebar-nav-pill'>http_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- " href="#hikari.impl.rest.RESTApp.proxy_settings"
class='sidebar-nav-pill'>proxy_settings</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClientImpl -- Implementation of the V6 and V7-compatible Discord HTTP API …" href="#hikari.impl.rest.RESTClientImpl"
class='sidebar-nav-pill'>RESTClientImpl</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_reaction -- Add a reaction emoji to a message in a given channel …" href="#hikari.impl.rest.RESTClientImpl.add_reaction"
class='sidebar-nav-pill'>add_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_role_to_member -- " href="#hikari.impl.rest.RESTClientImpl.add_role_to_member"
class='sidebar-nav-pill'>add_role_to_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_user_to_guild -- Add a user to a guild …" href="#hikari.impl.rest.RESTClientImpl.add_user_to_guild"
class='sidebar-nav-pill'>add_user_to_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="ban_member -- " href="#hikari.impl.rest.RESTClientImpl.ban_user"
class='sidebar-nav-pill'>ban_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="ban_user -- " href="#hikari.impl.rest.RESTClientImpl.ban_user"
class='sidebar-nav-pill'>ban_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="begin_guild_prune -- Begin the guild prune …" href="#hikari.impl.rest.RESTClientImpl.begin_guild_prune"
class='sidebar-nav-pill'>begin_guild_prune</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="buckets -- Bucket ratelimiter manager." href="#hikari.impl.rest.RESTClientImpl.buckets"
class='sidebar-nav-pill'>buckets</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Close the HTTP client and any open HTTP connections." href="#hikari.impl.rest.RESTClientImpl.close"
class='sidebar-nav-pill'>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_crossposts -- Broadcast an announcement message …" href="#hikari.impl.rest.RESTClientImpl.create_crossposts"
class='sidebar-nav-pill'>create_crossposts</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_dm_channel -- Create a DM channel with a user …" href="#hikari.impl.rest.RESTClientImpl.create_dm_channel"
class='sidebar-nav-pill'>create_dm_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_emoji -- " href="#hikari.impl.rest.RESTClientImpl.create_emoji"
class='sidebar-nav-pill'>create_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_category -- " href="#hikari.impl.rest.RESTClientImpl.create_guild_category"
class='sidebar-nav-pill'>create_guild_category</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_news_channel -- " href="#hikari.impl.rest.RESTClientImpl.create_guild_news_channel"
class='sidebar-nav-pill'>create_guild_news_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_text_channel -- " href="#hikari.impl.rest.RESTClientImpl.create_guild_text_channel"
class='sidebar-nav-pill'>create_guild_text_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_voice_channel -- " href="#hikari.impl.rest.RESTClientImpl.create_guild_voice_channel"
class='sidebar-nav-pill'>create_guild_voice_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_invite -- Create an invite to the given guild channel …" href="#hikari.impl.rest.RESTClientImpl.create_invite"
class='sidebar-nav-pill'>create_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_message -- Create a message in the given channel …" href="#hikari.impl.rest.RESTClientImpl.create_message"
class='sidebar-nav-pill'>create_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_role -- " href="#hikari.impl.rest.RESTClientImpl.create_role"
class='sidebar-nav-pill'>create_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_webhook -- Create webhook in a channel …" href="#hikari.impl.rest.RESTClientImpl.create_webhook"
class='sidebar-nav-pill'>create_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_all_reactions -- Delete all reactions from a message …" href="#hikari.impl.rest.RESTClientImpl.delete_all_reactions"
class='sidebar-nav-pill'>delete_all_reactions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_all_reactions_for_emoji -- Delete all reactions for a single emoji on a given message …" href="#hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji"
class='sidebar-nav-pill'>delete_all_reactions_for_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_channel -- Delete a channel in a guild, or close a DM …" href="#hikari.impl.rest.RESTClientImpl.delete_channel"
class='sidebar-nav-pill'>delete_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_emoji -- " href="#hikari.impl.rest.RESTClientImpl.delete_emoji"
class='sidebar-nav-pill'>delete_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_guild -- Delete a guild …" href="#hikari.impl.rest.RESTClientImpl.delete_guild"
class='sidebar-nav-pill'>delete_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_integration -- " href="#hikari.impl.rest.RESTClientImpl.delete_integration"
class='sidebar-nav-pill'>delete_integration</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_invite -- Delete an existing invite …" href="#hikari.impl.rest.RESTClientImpl.delete_invite"
class='sidebar-nav-pill'>delete_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_message -- Delete a given message in a given channel …" href="#hikari.impl.rest.RESTClientImpl.delete_message"
class='sidebar-nav-pill'>delete_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_messages -- Bulk-delete messages from the channel …" href="#hikari.impl.rest.RESTClientImpl.delete_messages"
class='sidebar-nav-pill'>delete_messages</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_my_reaction -- Delete a reaction that your application user created …" href="#hikari.impl.rest.RESTClientImpl.delete_my_reaction"
class='sidebar-nav-pill'>delete_my_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_permission_overwrite -- Delete a custom permission for an entity in a given guild channel …" href="#hikari.impl.rest.RESTClientImpl.delete_permission_overwrite"
class='sidebar-nav-pill'>delete_permission_overwrite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_reaction -- Delete a reaction from a message …" href="#hikari.impl.rest.RESTClientImpl.delete_reaction"
class='sidebar-nav-pill'>delete_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_role -- " href="#hikari.impl.rest.RESTClientImpl.delete_role"
class='sidebar-nav-pill'>delete_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_webhook -- Delete a webhook …" href="#hikari.impl.rest.RESTClientImpl.delete_webhook"
class='sidebar-nav-pill'>delete_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_channel -- Edit a channel …" href="#hikari.impl.rest.RESTClientImpl.edit_channel"
class='sidebar-nav-pill'>edit_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_emoji -- " href="#hikari.impl.rest.RESTClientImpl.edit_emoji"
class='sidebar-nav-pill'>edit_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_guild -- " href="#hikari.impl.rest.RESTClientImpl.edit_guild"
class='sidebar-nav-pill'>edit_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_integration -- " href="#hikari.impl.rest.RESTClientImpl.edit_integration"
class='sidebar-nav-pill'>edit_integration</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_member -- " href="#hikari.impl.rest.RESTClientImpl.edit_member"
class='sidebar-nav-pill'>edit_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_message -- Edit an existing message in a given channel …" href="#hikari.impl.rest.RESTClientImpl.edit_message"
class='sidebar-nav-pill'>edit_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_my_nick -- " href="#hikari.impl.rest.RESTClientImpl.edit_my_nick"
class='sidebar-nav-pill'>edit_my_nick</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_my_user -- Edit the token's associated user …" href="#hikari.impl.rest.RESTClientImpl.edit_my_user"
class='sidebar-nav-pill'>edit_my_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_permission_overwrites -- Edit permissions for a specific entity in the given guild channel …" href="#hikari.impl.rest.RESTClientImpl.edit_permission_overwrites"
class='sidebar-nav-pill'>edit_permission_overwrites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_role -- " href="#hikari.impl.rest.RESTClientImpl.edit_role"
class='sidebar-nav-pill'>edit_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_webhook -- Edit a webhook …" href="#hikari.impl.rest.RESTClientImpl.edit_webhook"
class='sidebar-nav-pill'>edit_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_widget -- " href="#hikari.impl.rest.RESTClientImpl.edit_widget"
class='sidebar-nav-pill'>edit_widget</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="estimate_guild_prune_count -- Estimate the guild prune count …" href="#hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count"
class='sidebar-nav-pill'>estimate_guild_prune_count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="execute_webhook -- Execute a webhook …" href="#hikari.impl.rest.RESTClientImpl.execute_webhook"
class='sidebar-nav-pill'>execute_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_application -- Fetch the token's associated application …" href="#hikari.impl.rest.RESTClientImpl.fetch_application"
class='sidebar-nav-pill'>fetch_application</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_audit_log -- " href="#hikari.impl.rest.RESTClientImpl.fetch_audit_log"
class='sidebar-nav-pill'>fetch_audit_log</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_ban -- " href="#hikari.impl.rest.RESTClientImpl.fetch_ban"
class='sidebar-nav-pill'>fetch_ban</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_bans -- " href="#hikari.impl.rest.RESTClientImpl.fetch_bans"
class='sidebar-nav-pill'>fetch_bans</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Fetch a channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_channel"
class='sidebar-nav-pill'>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel_invites -- Fetch all invites pointing to the given guild channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_channel_invites"
class='sidebar-nav-pill'>fetch_channel_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel_webhooks -- Fetch all channel webhooks …" href="#hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks"
class='sidebar-nav-pill'>fetch_channel_webhooks</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_emoji -- " href="#hikari.impl.rest.RESTClientImpl.fetch_emoji"
class='sidebar-nav-pill'>fetch_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_gateway_bot -- Fetch the gateway gateway info for the bot …" href="#hikari.impl.rest.RESTClientImpl.fetch_gateway_bot"
class='sidebar-nav-pill'>fetch_gateway_bot</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_gateway_url -- Fetch the gateway url …" href="#hikari.impl.rest.RESTClientImpl.fetch_gateway_url"
class='sidebar-nav-pill'>fetch_gateway_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild -- " href="#hikari.impl.rest.RESTClientImpl.fetch_guild"
class='sidebar-nav-pill'>fetch_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_channels -- " href="#hikari.impl.rest.RESTClientImpl.fetch_guild_channels"
class='sidebar-nav-pill'>fetch_guild_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_emojis -- " href="#hikari.impl.rest.RESTClientImpl.fetch_guild_emojis"
class='sidebar-nav-pill'>fetch_guild_emojis</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_invites -- " href="#hikari.impl.rest.RESTClientImpl.fetch_guild_invites"
class='sidebar-nav-pill'>fetch_guild_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_preview -- " href="#hikari.impl.rest.RESTClientImpl.fetch_guild_preview"
class='sidebar-nav-pill'>fetch_guild_preview</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_voice_regions -- " href="#hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions"
class='sidebar-nav-pill'>fetch_guild_voice_regions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_webhooks -- Fetch all guild webhooks …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks"
class='sidebar-nav-pill'>fetch_guild_webhooks</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_integrations -- " href="#hikari.impl.rest.RESTClientImpl.fetch_integrations"
class='sidebar-nav-pill'>fetch_integrations</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_invite -- Fetch an existing invite …" href="#hikari.impl.rest.RESTClientImpl.fetch_invite"
class='sidebar-nav-pill'>fetch_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_member -- " href="#hikari.impl.rest.RESTClientImpl.fetch_member"
class='sidebar-nav-pill'>fetch_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_members -- " href="#hikari.impl.rest.RESTClientImpl.fetch_members"
class='sidebar-nav-pill'>fetch_members</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_message -- Fetch a specific message in the given text channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_message"
class='sidebar-nav-pill'>fetch_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_messages -- Browse the message history for a given text channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_messages"
class='sidebar-nav-pill'>fetch_messages</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_my_connections -- Fetch the token's associated connections …" href="#hikari.impl.rest.RESTClientImpl.fetch_my_connections"
class='sidebar-nav-pill'>fetch_my_connections</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_my_guilds -- Fetch the token's associated guilds …" href="#hikari.impl.rest.RESTClientImpl.fetch_my_guilds"
class='sidebar-nav-pill'>fetch_my_guilds</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_my_user -- Fetch the token's associated user …" href="#hikari.impl.rest.RESTClientImpl.fetch_my_user"
class='sidebar-nav-pill'>fetch_my_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_pins -- Fetch the pinned messages in this text channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_pins"
class='sidebar-nav-pill'>fetch_pins</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_reactions_for_emoji -- Fetch reactions for an emoji from a message …" href="#hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji"
class='sidebar-nav-pill'>fetch_reactions_for_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_roles -- " href="#hikari.impl.rest.RESTClientImpl.fetch_roles"
class='sidebar-nav-pill'>fetch_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_user -- Fetch a user …" href="#hikari.impl.rest.RESTClientImpl.fetch_user"
class='sidebar-nav-pill'>fetch_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_vanity_url -- " href="#hikari.impl.rest.RESTClientImpl.fetch_vanity_url"
class='sidebar-nav-pill'>fetch_vanity_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_voice_regions -- Fetch available voice regions …" href="#hikari.impl.rest.RESTClientImpl.fetch_voice_regions"
class='sidebar-nav-pill'>fetch_voice_regions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_webhook -- Fetch an existing webhook …" href="#hikari.impl.rest.RESTClientImpl.fetch_webhook"
class='sidebar-nav-pill'>fetch_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_widget -- " href="#hikari.impl.rest.RESTClientImpl.fetch_widget"
class='sidebar-nav-pill'>fetch_widget</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="follow_channel -- Follow a news channel to send messages to a target channel …" href="#hikari.impl.rest.RESTClientImpl.follow_channel"
class='sidebar-nav-pill'>follow_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="global_rate_limit -- Global ratelimiter." href="#hikari.impl.rest.RESTClientImpl.global_rate_limit"
class='sidebar-nav-pill'>global_rate_limit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="guild_builder -- " href="#hikari.impl.rest.RESTClientImpl.guild_builder"
class='sidebar-nav-pill'>guild_builder</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return the HTTP settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.http_settings"
class='sidebar-nav-pill'>http_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="kick_member -- " href="#hikari.impl.rest.RESTClientImpl.kick_user"
class='sidebar-nav-pill'>kick_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="kick_user -- " href="#hikari.impl.rest.RESTClientImpl.kick_user"
class='sidebar-nav-pill'>kick_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="leave_guild -- Leave a guild …" href="#hikari.impl.rest.RESTClientImpl.leave_guild"
class='sidebar-nav-pill'>leave_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="pin_message -- Pin an existing message in the given text channel …" href="#hikari.impl.rest.RESTClientImpl.pin_message"
class='sidebar-nav-pill'>pin_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- Return the proxy settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.proxy_settings"
class='sidebar-nav-pill'>proxy_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="remove_role_from_member -- " href="#hikari.impl.rest.RESTClientImpl.remove_role_from_member"
class='sidebar-nav-pill'>remove_role_from_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="reposition_channels -- " href="#hikari.impl.rest.RESTClientImpl.reposition_channels"
class='sidebar-nav-pill'>reposition_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="reposition_roles -- " href="#hikari.impl.rest.RESTClientImpl.reposition_roles"
class='sidebar-nav-pill'>reposition_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="sync_integration -- " href="#hikari.impl.rest.RESTClientImpl.sync_integration"
class='sidebar-nav-pill'>sync_integration</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="trigger_typing -- Trigger typing in a text channel …" href="#hikari.impl.rest.RESTClientImpl.trigger_typing"
class='sidebar-nav-pill'>trigger_typing</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unban_member -- " href="#hikari.impl.rest.RESTClientImpl.unban_user"
class='sidebar-nav-pill'>unban_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unban_user -- " href="#hikari.impl.rest.RESTClientImpl.unban_user"
class='sidebar-nav-pill'>unban_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unpin_message -- Unpin a given message from a given text channel …" href="#hikari.impl.rest.RESTClientImpl.unpin_message"
class='sidebar-nav-pill'>unpin_message</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L0-L2331" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Implementation of a V6 and V7 compatible HTTP API for Discord.

This also includes implementations designed towards providing
RESTful functionality.
&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.Final[typing.List[str]] = [
    &#34;BasicLazyCachedTCPConnectorFactory&#34;,
    &#34;RESTApp&#34;,
    &#34;RESTClientImpl&#34;,
]

import asyncio
import collections
import contextlib
import datetime
import http
import logging
import math
import os
import platform
import re
import sys
import typing

import aiohttp
import attr

from hikari import _about as about
from hikari import channels
from hikari import config
from hikari import embeds as embeds_
from hikari import emojis
from hikari import errors
from hikari import files
from hikari import guilds
from hikari import iterators
from hikari import snowflakes
from hikari import traits
from hikari import undefined
from hikari import urls
from hikari import users
from hikari.api import cache as cache_
from hikari.api import rest as rest_api
from hikari.impl import buckets
from hikari.impl import entity_factory as entity_factory_impl
from hikari.impl import rate_limits
from hikari.impl import special_endpoints
from hikari.impl import stateless_cache
from hikari.utilities import data_binding
from hikari.utilities import date
from hikari.utilities import net
from hikari.utilities import routes
from hikari.utilities import ux

if typing.TYPE_CHECKING:
    import concurrent.futures
    import types

    from hikari import applications
    from hikari import audit_logs
    from hikari import colors
    from hikari import invites
    from hikari import messages as messages_
    from hikari import permissions as permissions_
    from hikari import sessions
    from hikari import voices
    from hikari import webhooks
    from hikari.api import entity_factory as entity_factory_

_LOGGER: typing.Final[logging.Logger] = logging.getLogger(&#34;hikari.rest&#34;)

_APPLICATION_JSON: typing.Final[str] = &#34;application/json&#34;
_APPLICATION_OCTET_STREAM: typing.Final[str] = &#34;application/octet-stream&#34;
_AUTHORIZATION_HEADER: typing.Final[str] = sys.intern(&#34;Authorization&#34;)
_BEARER_TOKEN_PREFIX: typing.Final[str] = &#34;Bearer&#34;  # nosec
_BOT_TOKEN_PREFIX: typing.Final[str] = &#34;Bot&#34;  # nosec
_DATE_HEADER: typing.Final[str] = sys.intern(&#34;Date&#34;)
_HTTP_USER_AGENT: typing.Final[str] = (
    f&#34;DiscordBot ({about.__url__}, {about.__version__}) {about.__author__} &#34;
    f&#34;AIOHTTP/{aiohttp.__version__} &#34;
    f&#34;{platform.python_implementation()}/{platform.python_version()} {platform.system()} {platform.architecture()[0]}&#34;
)
_MILLISECOND_PRECISION: typing.Final[str] = &#34;millisecond&#34;
_USER_AGENT_HEADER: typing.Final[str] = sys.intern(&#34;User-Agent&#34;)
_X_AUDIT_LOG_REASON_HEADER: typing.Final[str] = sys.intern(&#34;X-Audit-Log-Reason&#34;)
_X_RATELIMIT_BUCKET_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Bucket&#34;)
_X_RATELIMIT_LIMIT_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Limit&#34;)
_X_RATELIMIT_PRECISION_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Precision&#34;)
_X_RATELIMIT_REMAINING_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Remaining&#34;)
_X_RATELIMIT_RESET_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Reset&#34;)
_X_RATELIMIT_RESET_AFTER_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Reset-After&#34;)


@typing.final
class BasicLazyCachedTCPConnectorFactory(rest_api.ConnectorFactory):
    &#34;&#34;&#34;Lazy cached TCP connector factory.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;connector&#34;, &#34;http_settings&#34;)

    def __init__(self, http_settings: config.HTTPSettings) -&gt; None:
        self.connector: typing.Optional[aiohttp.TCPConnector] = None
        self.http_settings = http_settings

    async def close(self) -&gt; None:
        if self.connector is not None:
            await self.connector.close()
            self.connector = None

    def acquire(self) -&gt; aiohttp.BaseConnector:
        if self.connector is None:
            self.connector = net.create_tcp_connector(self.http_settings)

        return self.connector


class _RESTProvider(traits.RESTAware):
    __slots__: typing.Sequence[str] = (&#34;_entity_factory&#34;, &#34;_executor&#34;, &#34;_cache&#34;, &#34;_rest&#34;)

    def __init__(
        self,
        entity_factory: typing.Callable[[], entity_factory_.EntityFactory],
        executor: typing.Optional[concurrent.futures.Executor],
        cache: typing.Callable[[], cache_.Cache],
        rest: typing.Callable[[], rest_api.RESTClient],
    ) -&gt; None:
        self._entity_factory = entity_factory
        self._executor = executor
        self._cache = cache
        self._rest = rest

    @property
    def entity_factory(self) -&gt; entity_factory_.EntityFactory:
        return self._entity_factory()

    @property
    def executor(self) -&gt; typing.Optional[concurrent.futures.Executor]:
        return self._executor

    @property
    def cache(self) -&gt; cache_.Cache:
        return self._cache()

    @property
    def me(self) -&gt; typing.Optional[users.OwnUser]:
        return self._cache().get_me()

    @property
    def rest(self) -&gt; rest_api.RESTClient:
        return self._rest()

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._rest().http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._rest().proxy_settings


class RESTApp(traits.ExecutorAware):
    &#34;&#34;&#34;The base for a HTTP-only Discord application.

    This comprises of a shared TCP connector connection pool, and can have
    `RESTClientImpl` instances for specific credentials acquired
    from it.

    Parameters
    ----------
    connector_factory : typing.Optional[ConnectorFactory]
        A factory that produces an `aiohttp.BaseConnector` when requested.

        Defaults to a connector for a shared `aiohttp.TCPConnector` if
        `builtins.None`.

        The connector factory is expected to handle providing locks around
        resources and caching any result as desired.
    connector_owner : builtins.bool
        If you created the connector yourself, set this to `builtins.True` if
        you want this component to destroy the connector once closed. Otherwise,
        `builtins.False` will prevent this and you will have to do this
        manually. The latter is useful if you wish to maintain a shared
        connection pool across your application with other non-Hikari
        components.

        !!! warning
            If you do not give a `connector_factory`, this will be IGNORED
            and always be treated as `builtins.True` internally.
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking file IO operations. If `builtins.None`
        is passed, then the default `concurrent.futures.ThreadPoolExecutor` for
        the `asyncio.AbstractEventLoop` will be used instead.
    http_settings : typing.Optional[hikari.config.HTTPSettings]
        HTTP settings to use. Sane defaults are used if this is
        `builtins.None`.
    proxy_settings : typing.Optional[hikari.config.ProxySettings]
        Proxy settings to use. If `builtins.None` then no proxy configuration
        will be used.
    url : typing.Optional[builtins.str]
        The base URL for the API. You can generally leave this as being
        `builtins.None` and the correct default API base URL will be generated.

    !!! note
        This event loop will be bound to a connector when the first call
        to `acquire` is made.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_connector_factory&#34;,
        &#34;_connector_owner&#34;,
        &#34;_event_loop&#34;,
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_url&#34;,
    )

    def __init__(
        self,
        *,
        connector_factory: typing.Optional[rest_api.ConnectorFactory] = None,
        connector_owner: bool = True,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        http_settings: typing.Optional[config.HTTPSettings] = None,
        proxy_settings: typing.Optional[config.ProxySettings] = None,
        url: typing.Optional[str] = None,
    ) -&gt; None:
        self._http_settings = config.HTTPSettings() if http_settings is None else http_settings
        self._proxy_settings = config.ProxySettings() if proxy_settings is None else proxy_settings

        # Lazy initialized later, since we must initialize this in the event
        # loop we run the application from, otherwise aiohttp throws complaints
        # at us. Quart, amongst other libraries, causes issues with this by
        # making a new event loop on startup, which means if we initialised
        # the connector here and initialised this class in global scope, it
        # would potentially end up using the wrong event loop and aiohttp
        # would then fail when creating an HTTP request.
        if connector_factory is None:
            connector_factory = BasicLazyCachedTCPConnectorFactory(self._http_settings)
            connector_owner = True

        self._connector_factory = connector_factory
        self._connector_owner = connector_owner
        self._event_loop: typing.Optional[asyncio.AbstractEventLoop] = None
        self._executor = executor
        self._url = url

    @property
    def executor(self) -&gt; typing.Optional[concurrent.futures.Executor]:
        return self._executor

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    def acquire(self, token: str, token_type: str = _BEARER_TOKEN_PREFIX) -&gt; rest_api.RESTClient:
        loop = asyncio.get_running_loop()

        if self._event_loop is None:
            self._event_loop = loop

        if loop != self._event_loop:
            raise RuntimeError(&#34;Cannot use this object on a different event loop... please create a new instance.&#34;)

        # Since we essentially mimic a fake App instance, we need to make a circular provider.
        # We can achieve this using a lambda. This allows the entity factory to build models that
        # are also REST-aware
        cache = stateless_cache.StatelessCacheImpl()
        provider = _RESTProvider(
            lambda: entity_factory,
            self._executor,
            lambda: cache,
            lambda: rest_client,
        )
        entity_factory = entity_factory_impl.EntityFactoryImpl(provider)

        rest_client = RESTClientImpl(
            connector_factory=self._connector_factory,
            connector_owner=self._connector_owner,
            entity_factory=entity_factory,
            executor=self._executor,
            http_settings=self._http_settings,
            proxy_settings=self._proxy_settings,
            token=token,
            token_type=token_type,
            rest_url=self._url,
        )

        return rest_client

    async def close(self) -&gt; None:
        if self._connector_owner:
            await self._connector_factory.close()

    async def __aenter__(self) -&gt; RESTApp:
        return self

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self.close()

    def __enter__(self) -&gt; typing.NoReturn:
        # This is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

    def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
        return None


class RESTClientImpl(rest_api.RESTClient):
    &#34;&#34;&#34;Implementation of the V6 and V7-compatible Discord HTTP API.

    This manages making HTTP/1.1 requests to the API and using the entity
    factory within the passed application instance to deserialize JSON responses
    to Pythonic data classes that are used throughout this library.

    Parameters
    ----------
    connector_factory : typing.Optional[ConnectorFactory]
        A factory that produces an `aiohttp.BaseConnector` when requested.

        Defaults to a connector for a shared `aiohttp.TCPConnector` if
        `builtins.None`.

        The connector factory is expected to handle providing locks around
        resources and caching any result as desired.
    connector_owner : builtins.bool
        If you created the connector yourself, set this to `builtins.True` if
        you want this component to destroy the connector once closed. Otherwise,
        `builtins.False` will prevent this and you will have to do this
        manually. The latter is useful if you wish to maintain a shared
        connection pool across your application with other non-Hikari
        components.
    entity_factory : hikari.api.entity_factory.EntityFactory
        The entity factory to use.
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking IO. Defaults to the `asyncio` thread
        pool if set to `builtins.None`.
    token : hikari.undefined.UndefinedOr[builtins.str]
        The bot or bearer token. If no token is to be used,
        this can be undefined.
    token_type : hikari.undefined.UndefinedOr[builtins.str]
        The type of token in use. If no token is used, this can be ignored and
        left to the default value. This can be `&#34;Bot&#34;` or `&#34;Bearer&#34;`.
    rest_url : builtins.str
        The HTTP API base URL. This can contain format-string specifiers to
        interpolate information such as API version in use.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;buckets&#34;,
        &#34;global_rate_limit&#34;,
        &#34;_client_session&#34;,
        &#34;_closed_event&#34;,
        &#34;_connector_factory&#34;,
        &#34;_connector_owner&#34;,
        &#34;_entity_factory&#34;,
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_rest_url&#34;,
        &#34;_token&#34;,
    )

    buckets: buckets.RESTBucketManager
    &#34;&#34;&#34;Bucket ratelimiter manager.&#34;&#34;&#34;

    global_rate_limit: rate_limits.ManualRateLimiter
    &#34;&#34;&#34;Global ratelimiter.&#34;&#34;&#34;

    @attr.s(auto_exc=True, slots=True, repr=False, weakref_slot=False)
    class _RetryRequest(RuntimeError):
        ...

    def __init__(
        self,
        *,
        connector_factory: rest_api.ConnectorFactory,
        connector_owner: bool,
        entity_factory: entity_factory_.EntityFactory,
        executor: typing.Optional[concurrent.futures.Executor],
        http_settings: config.HTTPSettings,
        proxy_settings: config.ProxySettings,
        token: typing.Optional[str],
        token_type: typing.Optional[str] = None,
        rest_url: typing.Optional[str],
    ) -&gt; None:
        self.buckets = buckets.RESTBucketManager()
        # We&#39;ve been told in DAPI that this is per token.
        self.global_rate_limit = rate_limits.ManualRateLimiter()

        self._client_session: typing.Optional[aiohttp.ClientSession] = None
        self._closed_event = asyncio.Event()
        self._connector_factory = connector_factory
        self._connector_owner = connector_owner
        self._entity_factory = entity_factory
        self._executor = executor
        self._http_settings = http_settings
        self._proxy_settings = proxy_settings

        if token is None:
            full_token = None
        else:
            if token_type is None:
                token_type = _BOT_TOKEN_PREFIX

            full_token = f&#34;{token_type.title()} {token}&#34;

        self._token: typing.Optional[str] = full_token

        self._rest_url = rest_url if rest_url is not None else urls.REST_API_URL

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    @typing.final
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the HTTP client and any open HTTP connections.&#34;&#34;&#34;
        if self._client_session is not None:
            await self._client_session.close()
        await self._connector_factory.close()
        self.global_rate_limit.close()
        self.buckets.close()
        self._closed_event.set()
        # We have to sleep to allow aiohttp time to close SSL transports...
        # https://github.com/aio-libs/aiohttp/issues/1925
        # https://docs.aiohttp.org/en/stable/client_advanced.html#graceful-shutdown
        await asyncio.sleep(0.25)

    async def __aenter__(self) -&gt; RESTClientImpl:
        return self

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self.close()

    def __enter__(self) -&gt; typing.NoReturn:
        # This is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

    def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
        return None

    @typing.final
    def _acquire_client_session(self) -&gt; aiohttp.ClientSession:
        if self._client_session is None:
            self._closed_event.clear()
            self._client_session = net.create_client_session(
                connector=self._connector_factory.acquire(),
                # No, this is correct. We manage closing the connector ourselves in this class if we are
                # told we own it. This works around some other lifespan issues.
                connector_owner=False,
                http_settings=self._http_settings,
                raise_for_status=False,
                trust_env=self._proxy_settings.trust_env,
            )
            _LOGGER.log(ux.TRACE, &#34;acquired new aiohttp client session&#34;)

        elif self._client_session.closed:
            raise errors.HTTPClientClosedError

        return self._client_session

    @typing.final
    async def _request(
        self,
        compiled_route: routes.CompiledRoute,
        *,
        query: typing.Optional[data_binding.StringMapBuilder] = None,
        form: typing.Optional[aiohttp.FormData] = None,
        json: typing.Union[data_binding.JSONObjectBuilder, data_binding.JSONArray, None] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        no_auth: bool = False,
    ) -&gt; typing.Union[None, data_binding.JSONObject, data_binding.JSONArray]:
        # Make a ratelimit-protected HTTP request to a JSON endpoint and expect some form
        # of JSON response. If an error occurs, the response body is returned in the
        # raised exception as a bytes object. This is done since the differences between
        # the V6 and V7 API error messages are not documented properly, and there are
        # edge cases such as Cloudflare issues where we may receive arbitrary data in
        # the response instead of a JSON object.

        if not self.buckets.is_started:
            self.buckets.start()

        headers = data_binding.StringMapBuilder()
        headers.setdefault(_USER_AGENT_HEADER, _HTTP_USER_AGENT)
        headers.put(_X_RATELIMIT_PRECISION_HEADER, _MILLISECOND_PRECISION)

        if self._token is not None and not no_auth:
            headers[_AUTHORIZATION_HEADER] = self._token

        headers.put(_X_AUDIT_LOG_REASON_HEADER, reason)

        while True:
            try:
                url = compiled_route.create_url(self._rest_url)

                # Wait for any rate-limits to finish.
                await asyncio.gather(self.buckets.acquire(compiled_route), self.global_rate_limit.acquire())

                uuid = date.uuid()

                if _LOGGER.getEffectiveLevel() &lt;= ux.TRACE:
                    _LOGGER.log(
                        ux.TRACE,
                        &#34;%s %s %s\n%s&#34;,
                        uuid,
                        compiled_route.method,
                        url,
                        self._stringify_http_message(headers, json),
                    )

                # Make the request.
                session = self._acquire_client_session()
                start = date.monotonic()
                response = await session.request(
                    compiled_route.method,
                    url,
                    headers=headers,
                    params=query,
                    json=json,
                    data=form,
                    allow_redirects=self._http_settings.max_redirects is not None,
                    max_redirects=self._http_settings.max_redirects,
                    proxy=self._proxy_settings.url,
                    proxy_headers=self._proxy_settings.all_headers,
                )
                time_taken = (date.monotonic() - start) * 1_000

                if _LOGGER.getEffectiveLevel() &lt;= ux.TRACE:
                    _LOGGER.log(
                        ux.TRACE,
                        &#34;%s %s %s in %sms\n%s&#34;,
                        uuid,
                        response.status,
                        response.reason,
                        time_taken,
                        self._stringify_http_message(response.headers, await response.read()),
                    )

                # Ensure we are not rate limited, and update rate limiting headers where appropriate.
                await self._parse_ratelimits(compiled_route, response)

                # Don&#39;t bother processing any further if we got NO CONTENT. There&#39;s not anything
                # to check.
                if response.status == http.HTTPStatus.NO_CONTENT:
                    return None

                # Handle the response.
                if 200 &lt;= response.status &lt; 300:
                    if response.content_type == _APPLICATION_JSON:
                        # Only deserializing here stops Cloudflare shenanigans messing us around.
                        return data_binding.load_json(await response.read())

                    real_url = str(response.real_url)
                    raise errors.HTTPError(f&#34;Expected JSON [{response.content_type=}, {real_url=}]&#34;)

                await self._handle_error_response(response)

            except self._RetryRequest:
                continue

    @typing.final
    def _stringify_http_message(self, headers: data_binding.Headers, body: typing.Any) -&gt; str:
        string = &#34;\n&#34;.join(
            f&#34;    {name}: {value}&#34; if name != _AUTHORIZATION_HEADER else f&#34;    {name}: **REDACTED TOKEN**&#34;
            for name, value in headers.items()
        )

        if body is not None:
            string += &#34;\n\n    &#34;
            string += body.decode(&#34;ascii&#34;) if isinstance(body, bytes) else str(body)

        return string

    @staticmethod
    @typing.final
    async def _handle_error_response(response: aiohttp.ClientResponse) -&gt; typing.NoReturn:
        raise await net.generate_error_response(response)

    @typing.final
    async def _parse_ratelimits(self, compiled_route: routes.CompiledRoute, response: aiohttp.ClientResponse) -&gt; None:
        # Worth noting there is some bug on V6 that rate limits me immediately if I have an invalid token.
        # https://github.com/discord/discord-api-docs/issues/1569

        # Handle rate limiting.
        resp_headers = response.headers
        limit = int(resp_headers.get(_X_RATELIMIT_LIMIT_HEADER, &#34;1&#34;))
        remaining = int(resp_headers.get(_X_RATELIMIT_REMAINING_HEADER, &#34;1&#34;))
        bucket = resp_headers.get(_X_RATELIMIT_BUCKET_HEADER, &#34;None&#34;)
        reset_at = float(resp_headers.get(_X_RATELIMIT_RESET_HEADER, &#34;0&#34;))
        reset_after = float(resp_headers.get(_X_RATELIMIT_RESET_AFTER_HEADER, &#34;0&#34;))
        reset_date = datetime.datetime.fromtimestamp(reset_at, tz=datetime.timezone.utc)
        now_date = date.rfc7231_datetime_string_to_datetime(resp_headers[_DATE_HEADER])

        is_rate_limited = response.status == http.HTTPStatus.TOO_MANY_REQUESTS

        self.buckets.update_rate_limits(
            compiled_route=compiled_route,
            bucket_header=bucket,
            remaining_header=remaining,
            limit_header=limit,
            date_header=now_date,
            reset_at_header=reset_date,
        )

        if not is_rate_limited:
            return

        if response.content_type != _APPLICATION_JSON:
            # We don&#39;t know exactly what this could imply. It is likely Cloudflare interfering
            # but I&#39;d rather we just give up than do something resulting in multiple failed
            # requests repeatedly.
            raise errors.HTTPResponseError(
                str(response.real_url),
                http.HTTPStatus.TOO_MANY_REQUESTS,
                response.headers,
                await response.read(),
                f&#34;received rate limited response with unexpected response type {response.content_type}&#34;,
            )

        body = await response.json()
        body_retry_after = float(body[&#34;retry_after&#34;]) / 1_000

        if body.get(&#34;global&#34;, False) is True:
            self.global_rate_limit.throttle(body_retry_after)

            raise self._RetryRequest

        # Discord have started applying ratelimits to operations on some endpoints
        # based on specific fields used in the JSON body.
        # This does not get reflected in the headers. The first we know is when we
        # get a 429.
        # The issue is that we may get the same response if Discord dynamically
        # adjusts the bucket ratelimits.
        #
        # We have no mechanism for handing field-based ratelimits, so if we get
        # to here, but notice remaining is greater than zero, we should just error.
        #
        # Worth noting we still ignore the retry_after in the body. I have no clue
        # if there is some weird edge case where a bucket rate limit can occur on
        # top of a non-global one, but in this case this check will misbehave and
        # instead of erroring, will trigger a backoff that might be 10 minutes or
        # more...
        #
        # Seems Discord may raise this on some other undocumented cases, which
        # is nice of them. Apparently some dude spamming slurs in the Python
        # guild via a leaked webhook URL made people&#39;s clients exhibit this
        # behaviour.

        # I realise remaining should never be less than zero, but quite frankly, I don&#39;t
        # trust that voodoo type stuff will not ever occur with that value from them...
        if remaining &lt;= 0:
            # We can retry and we will then abide by the updated bucket ratelimits.
            _LOGGER.debug(
                &#34;rate-limited on bucket %s at %s. This is a bucket discrepancy, so we will retry at %s&#34;,
                bucket,
                compiled_route,
                reset_date,
            )

        # If the values are within 20% of eachother by relativistic tolerance, it is probably
        # safe to retry the request, as they are likely the same value just with some
        # measuring difference. 20% was used as a rounded figure.
        if math.isclose(body_retry_after, reset_after, rel_tol=0.20):
            raise self._RetryRequest

        raise errors.RateLimitedError(
            url=str(response.real_url),
            route=compiled_route,
            headers=response.headers,
            raw_body=body,
            retry_after=body_retry_after,
        )

    @staticmethod
    @typing.final
    def _generate_allowed_mentions(
        mentions_everyone: undefined.UndefinedOr[bool],
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ],
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ],
    ) -&gt; data_binding.JSONObject:
        parsed_mentions: typing.List[str] = []
        allowed_mentions = {&#34;parse&#34;: parsed_mentions}

        if mentions_everyone is True:
            parsed_mentions.append(&#34;everyone&#34;)

        if user_mentions is True:
            parsed_mentions.append(&#34;users&#34;)
        elif isinstance(user_mentions, typing.Collection):
            # Duplicates will cause discord to error.
            ids = {str(int(u)) for u in user_mentions}
            allowed_mentions[&#34;users&#34;] = list(ids)

        if role_mentions is True:
            parsed_mentions.append(&#34;roles&#34;)
        elif isinstance(role_mentions, typing.Collection):
            # Duplicates will cause discord to error.
            ids = {str(int(r)) for r in role_mentions}
            allowed_mentions[&#34;roles&#34;] = list(ids)

        return allowed_mentions

    async def fetch_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]
    ) -&gt; channels.PartialChannel:
        route = routes.GET_CHANNEL.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_channel(response)

    async def edit_channel(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        /,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        parent_category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.PartialChannel:
        route = routes.PATCH_CHANNEL.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user)
        body.put_snowflake(&#34;parent_id&#34;, parent_category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_channel(response)

    async def follow_channel(
        self,
        news_channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        target_channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.ChannelFollow:
        route = routes.POST_CHANNEL_FOLLOWERS.compile(channel=news_channel)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;webhook_channel_id&#34;, target_channel)

        raw_response = await self._request(route, json=body, reason=reason)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_channel_follow(response)

    async def delete_channel(self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]) -&gt; None:
        route = routes.DELETE_CHANNEL.compile(channel=channel)
        await self._request(route)

    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: typing.Union[
            snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels.PermissionOverwrite
        ],
        *,
        target_type: undefined.UndefinedOr[typing.Union[channels.PermissionOverwriteType, str]] = undefined.UNDEFINED,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if target_type is undefined.UNDEFINED:
            if isinstance(target, users.PartialUser):
                target_type = channels.PermissionOverwriteType.MEMBER
            elif isinstance(target, guilds.Role):
                target_type = channels.PermissionOverwriteType.ROLE
            elif isinstance(target, channels.PermissionOverwrite):
                target_type = target.type
            else:
                raise TypeError(
                    &#34;Cannot determine the type of the target to update. Try specifying &#39;target_type&#39; manually.&#34;
                )

        route = routes.PATCH_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, target_type)
        body.put(&#34;allow&#34;, allow)
        body.put(&#34;deny&#34;, deny)

        await self._request(route, json=body, reason=reason)

    async def delete_permission_overwrite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: snowflakes.SnowflakeishOr[
            typing.Union[channels.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
        ],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        await self._request(route)

    async def fetch_channel_invites(
        self, channel: snowflakes.SnowflakeishOr[channels.GuildChannel]
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_CHANNEL_INVITES.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_invite_with_metadata)

    async def create_invite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        *,
        max_age: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        target_user_type: undefined.UndefinedOr[invites.TargetUserType] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        route = routes.POST_CHANNEL_INVITES.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;max_age&#34;, max_age, conversion=date.timespan_to_int)
        body.put(&#34;max_uses&#34;, max_uses)
        body.put(&#34;temporary&#34;, temporary)
        body.put(&#34;unique&#34;, unique)
        body.put_snowflake(&#34;target_user_id&#34;, target_user)
        body.put(&#34;target_user_type&#34;, target_user_type)
        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_invite_with_metadata(response)

    def trigger_typing(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; special_endpoints.TypingIndicator:
        return special_endpoints.TypingIndicator(
            request_call=self._request, channel=channel, rest_closed_event=self._closed_event
        )

    async def fetch_pins(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; typing.Sequence[messages_.Message]:
        route = routes.GET_CHANNEL_PINS.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_message)

    async def pin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.PUT_CHANNEL_PINS.compile(channel=channel, message=message)
        await self._request(route)

    async def unpin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PIN.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[messages_.Message]:
        if undefined.count(before, after, around) &lt; 2:
            raise TypeError(&#34;Expected no kwargs, or maximum of one of &#39;before&#39;, &#39;after&#39;, &#39;around&#39;&#34;)

        timestamp: undefined.UndefinedOr[str]

        if before is not undefined.UNDEFINED:
            direction = &#34;before&#34;
            if isinstance(before, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(before))
            else:
                timestamp = str(int(before))
        elif after is not undefined.UNDEFINED:
            direction = &#34;after&#34;
            if isinstance(after, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(after))
            else:
                timestamp = str(int(after))
        elif around is not undefined.UNDEFINED:
            direction = &#34;around&#34;
            if isinstance(around, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(around))
            else:
                timestamp = str(int(around))
        else:
            direction = &#34;before&#34;
            timestamp = undefined.UNDEFINED

        return special_endpoints.MessageIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            direction=direction,
            first_id=timestamp,
        )

    async def fetch_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; messages_.Message:
        route = routes.GET_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def create_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        if not undefined.count(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not isinstance(attachments, typing.Collection) and attachments is not undefined.UNDEFINED:
            raise ValueError(
                &#34;You passed a non-collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        route = routes.POST_CHANNEL_MESSAGES.compile(channel=channel)

        if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
            # Syntatic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        elif undefined.count(attachment, attachments) == 2 and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntatic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;allowed_mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions))
        body.put(&#34;content&#34;, content, conversion=str)
        body.put(&#34;nonce&#34;, nonce)
        body.put(&#34;tts&#34;, tts)

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []

        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        if embed is not undefined.UNDEFINED:
            embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
            body.put(&#34;embed&#34;, embed_payload)
            final_attachments.extend(embed_attachments)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()

            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=_APPLICATION_OCTET_STREAM)

                raw_response = await self._request(route, form=form)
            finally:
                await stack.aclose()
        else:
            raw_response = await self._request(route, json=body)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def create_crossposts(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; messages_.Message:
        route = routes.POST_CHANNEL_CROSSPOST.compile(channel=channel, message=message)

        raw_response = await self._request(route)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def edit_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
        flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.PATCH_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;flags&#34;, flags)
        if undefined.count(mentions_everyone, user_mentions, role_mentions) != 3:
            body.put(
                &#34;allowed_mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions)
            )

        if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
            # Syntatic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        if content is not None:
            body.put(&#34;content&#34;, content, conversion=str)
        else:
            body.put(&#34;content&#34;, None)

        if isinstance(embed, embeds_.Embed):
            embed_payload, _ = self._entity_factory.serialize_embed(embed)
            body.put(&#34;embed&#34;, embed_payload)
        elif embed is None:
            body.put(&#34;embed&#34;, None)

        raw_response = await self._request(route, json=body)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def delete_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        await self._request(route)

    async def delete_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        /,
        *messages: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.POST_DELETE_CHANNEL_MESSAGES_BULK.compile(channel=channel)

        pending: typing.Deque[snowflakes.SnowflakeishOr[messages_.Message]] = collections.deque(messages)
        deleted: typing.Deque[snowflakes.SnowflakeishOr[messages_.Message]] = collections.deque()

        while pending:
            # Discord only allows 2-100 messages in the BULK_DELETE endpoint. Because of that,
            # if the user wants 101 messages deleted, we will post 100 messages in bulk delete
            # and then the last message in a normal delete.
            # Along with this, the bucket size for v6 and v7 seems to be a bit restrictive. As of
            # 30th July 2020, this endpoint returned the following headers when being ratelimited:
            #       x-ratelimit-bucket         b05c0d8c2ab83895085006a8eae073a3
            #       x-ratelimit-limit          1
            #       x-ratelimit-remaining      0
            #       x-ratelimit-reset          1596033974.096
            #       x-ratelimit-reset-after    3.000
            # This kind of defeats the point of asynchronously gathering any of these
            # in the first place really. To save clogging up the event loop
            # (albeit at a cost of maybe a couple-dozen milliseconds per call),
            # I am just gonna invoke these sequentially instead.
            try:
                if len(pending) == 1:
                    message = pending.popleft()
                    await self.delete_message(channel, message)
                    deleted.append(message)
                else:
                    body = data_binding.JSONObjectBuilder()
                    chunk = [pending.popleft() for _ in range(min(100, len(pending)))]
                    body.put_snowflake_array(&#34;messages&#34;, chunk)
                    await self._request(route, json=body)
                    deleted += chunk
            except Exception as ex:
                raise errors.BulkDeleteError(deleted, pending) from ex

    # Custom emoji mentions are in the format of &lt;:name:id&gt; for static emoji, or
    # &lt;a:name:id&gt; for animated emoji.
    _CUSTOM_EMOJI_PATTERN: typing.Final[typing.ClassVar[re.Pattern[str]]] = re.compile(r&#34;&lt;a?:([^:]+:\d+)&gt;&#34;)

    def _transform_emoji_to_url_format(self, emoji: emojis.Emojiish) -&gt; str:
        # Given an emojiish, check if it is a valid custom emoji mention. If it
        # is, then convert it to the name:id format (remove the wrapping
        # characters), then return it. If the emoji is an emojis.CustomEmoji
        # directly, then get the url_name of it. All other emojis and objects
        # can just be cast to string, as they are probably unicode emoji objects
        # or unicode emoji strings.
        if isinstance(emoji, emojis.CustomEmoji):
            return emoji.url_name

        if isinstance(emoji, str) and (custom_mention_match := self._CUSTOM_EMOJI_PATTERN.match(emoji)) is not None:
            # False positive in PyCharm, yet again.
            return custom_mention_match.group(1)

        return str(emoji)

    async def add_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        route = routes.PUT_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_my_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        route = routes.DELETE_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_all_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        route = routes.DELETE_REACTION_EMOJI.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; None:
        route = routes.DELETE_REACTION_USER.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
            user=user,
        )
        await self._request(route)

    async def delete_all_reactions(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.DELETE_ALL_REACTIONS.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; iterators.LazyIterator[users.User]:
        return special_endpoints.ReactorIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            message=message,
            emoji=self._transform_emoji_to_url_format(emoji),
        )

    async def create_webhook(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        name: str,
        *,
        avatar: typing.Optional[files.Resourceish] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        route = routes.POST_CHANNEL_WEBHOOKS.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)

        if avatar is not None:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_webhook(response)

    async def fetch_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        if token is undefined.UNDEFINED:
            route = routes.GET_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.GET_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        raw_response = await self._request(route, no_auth=no_auth)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_webhook(response)

    async def fetch_channel_webhooks(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        route = routes.GET_CHANNEL_WEBHOOKS.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_webhook)

    async def fetch_guild_webhooks(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        route = routes.GET_GUILD_WEBHOOKS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_webhook)

    async def edit_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.TextChannel]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        if token is undefined.UNDEFINED:
            route = routes.PATCH_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.PATCH_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake(&#34;channel&#34;, channel)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        raw_response = await self._request(route, json=body, reason=reason, no_auth=no_auth)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_webhook(response)

    async def delete_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if token is undefined.UNDEFINED:
            route = routes.DELETE_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.DELETE_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        await self._request(route, no_auth=no_auth)

    async def execute_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        token: str,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        if not undefined.count(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not undefined.count(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if not isinstance(embeds, typing.Collection) and embeds is not undefined.UNDEFINED:
            raise TypeError(
                &#34;You passed a non collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if not isinstance(attachments, typing.Collection) and attachments is not undefined.UNDEFINED:
            raise TypeError(
                &#34;You passed a non collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        if undefined.count(embed, embeds) == 2 and isinstance(content, embeds_.Embed):
            # Syntatic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        elif undefined.count(attachment, attachments) == 2 and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntatic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        route = routes.POST_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []
        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        serialized_embeds: data_binding.JSONArray = []

        if embeds is not undefined.UNDEFINED:
            for embed in embeds:
                embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                serialized_embeds.append(embed_payload)
                final_attachments.extend(embed_attachments)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions))
        body.put(&#34;content&#34;, content, conversion=str)
        body.put(&#34;embeds&#34;, serialized_embeds)
        body.put(&#34;username&#34;, username)
        body.put(&#34;avatar_url&#34;, avatar_url)
        body.put(&#34;tts&#34;, tts)
        query = data_binding.StringMapBuilder()
        query.put(&#34;wait&#34;, True)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()

            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=_APPLICATION_OCTET_STREAM)

                raw_response = await self._request(route, query=query, form=form, no_auth=True)
            finally:
                await stack.aclose()
        else:
            raw_response = await self._request(route, query=query, json=body, no_auth=True)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def fetch_gateway_url(self) -&gt; str:
        route = routes.GET_GATEWAY.compile()
        # This doesn&#39;t need authorization.
        raw_response = await self._request(route, no_auth=True)
        response = typing.cast(&#34;typing.Mapping[str, str]&#34;, raw_response)
        return response[&#34;url&#34;]

    async def fetch_gateway_bot(self) -&gt; sessions.GatewayBot:
        route = routes.GET_GATEWAY_BOT.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_gateway_bot(response)

    async def fetch_invite(self, invite: invites.Inviteish) -&gt; invites.Invite:
        route = routes.GET_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        raw_response = await self._request(route, query=query)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_invite(response)

    async def delete_invite(self, invite: invites.Inviteish) -&gt; None:
        route = routes.DELETE_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        await self._request(route)

    async def fetch_my_user(self) -&gt; users.OwnUser:
        route = routes.GET_MY_USER.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_my_user(response)

    async def edit_my_user(
        self,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; users.OwnUser:
        route = routes.PATCH_MY_USER.compile()
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;username&#34;, username)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        raw_response = await self._request(route, json=body)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_my_user(response)

    async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
        route = routes.GET_MY_CONNECTIONS.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_own_connection)

    def fetch_my_guilds(
        self,
        *,
        newest_first: bool = False,
        start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[applications.OwnGuild]:
        if start_at is undefined.UNDEFINED:
            start_at = snowflakes.Snowflake.max() if newest_first else snowflakes.Snowflake.min()
        elif isinstance(start_at, datetime.datetime):
            start_at = snowflakes.Snowflake.from_datetime(start_at)
        else:
            start_at = int(start_at)

        return special_endpoints.OwnGuildIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            newest_first=newest_first,
            first_id=str(start_at),
        )

    async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
        route = routes.DELETE_MY_GUILD.compile(guild=guild)
        await self._request(route)

    async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels.DMChannel:
        route = routes.POST_MY_CHANNELS.compile()
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;recipient_id&#34;, user)
        raw_response = await self._request(route, json=body)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_dm(response)

    async def fetch_application(self) -&gt; applications.Application:
        route = routes.GET_MY_APPLICATION.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_application(response)

    async def add_user_to_guild(
        self,
        access_token: str,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[guilds.Member]:
        route = routes.PUT_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;access_token&#34;, access_token)
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if (raw_response := await self._request(route, json=body)) is not None:
            response = typing.cast(data_binding.JSONObject, raw_response)
            return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))
        else:
            # User already is in the guild.
            return None

    async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_VOICE_REGIONS.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_voice_region)

    async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
        route = routes.GET_USER.compile(user=user)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_user(response)

    def fetch_audit_log(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        event_type: undefined.UndefinedOr[audit_logs.AuditLogEventType] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:

        timestamp: undefined.UndefinedOr[str]
        if before is undefined.UNDEFINED:
            timestamp = undefined.UNDEFINED
        elif isinstance(before, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(before))
        else:
            timestamp = str(int(before))

        return special_endpoints.AuditLogIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            guild=guild,
            before=timestamp,
            user=user,
            action_type=event_type,
        )

    async def fetch_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
        # likewise this only is valid for custom emojis, unicode emojis make little sense here.
        emoji: typing.Union[str, emojis.CustomEmoji],
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.GET_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def fetch_guild_emojis(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
        route = routes.GET_GUILD_EMOJIS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(
            response, self._entity_factory.deserialize_known_custom_emoji, guild_id=snowflakes.Snowflake(guild)
        )

    async def create_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        image: files.Resourceish,
        *,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.POST_GUILD_EMOJIS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        image_resource = files.ensure_resource(image)
        async with image_resource.stream(executor=self._executor) as stream:
            body.put(&#34;image&#34;, await stream.data_uri())

        body.put_snowflake_array(&#34;roles&#34;, roles)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def edit_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
        # likewise this only is valid for custom emojis, unicode emojis make little sense here.
        emoji: typing.Union[str, emojis.CustomEmoji],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.PATCH_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
        # likewise this only is valid for custom emojis, unicode emojis make little sense here.
        emoji: typing.Union[str, emojis.CustomEmoji],
    ) -&gt; None:
        route = routes.DELETE_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
        await self._request(route)

    def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
        return special_endpoints.GuildBuilder(
            entity_factory=self._entity_factory, executor=self._executor, request_call=self._request, name=name
        )

    async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
        route = routes.GET_GUILD.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        raw_response = await self._request(route, query=query)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_rest_guild(response)

    async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
        route = routes.GET_GUILD_PREVIEW.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_preview(response)

    async def edit_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[voices.VoiceRegionish] = undefined.UNDEFINED,
        verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
        default_message_notifications: undefined.UndefinedOr[
            guilds.GuildMessageNotificationsLevel
        ] = undefined.UNDEFINED,
        explicit_content_filter_level: undefined.UndefinedOr[
            guilds.GuildExplicitContentFilterLevel
        ] = undefined.UNDEFINED,
        afk_channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]] = undefined.UNDEFINED,
        afk_timeout: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        system_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        rules_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        public_updates_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        route = routes.PATCH_GUILD.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;region&#34;, region, conversion=str)
        body.put(&#34;verification&#34;, verification_level)
        body.put(&#34;notifications&#34;, default_message_notifications)
        body.put(&#34;explicit_content_filter&#34;, explicit_content_filter_level)
        body.put(&#34;afk_timeout&#34;, afk_timeout)
        body.put(&#34;preferred_locale&#34;, preferred_locale, conversion=str)
        body.put_snowflake(&#34;afk_channel_id&#34;, afk_channel)
        body.put_snowflake(&#34;owner_id&#34;, owner)
        body.put_snowflake(&#34;system_channel_id&#34;, system_channel)
        body.put_snowflake(&#34;rules_channel_id&#34;, rules_channel)
        body.put_snowflake(&#34;public_updates_channel_id&#34;, public_updates_channel)

        tasks: typing.List[asyncio.Task[str]] = []

        if icon is None:
            body.put(&#34;icon&#34;, None)
        elif icon is not undefined.UNDEFINED:
            icon_resource = files.ensure_resource(icon)
            async with icon_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;icon&#34;, future.result()))
                tasks.append(task)

        if splash is None:
            body.put(&#34;splash&#34;, None)
        elif splash is not undefined.UNDEFINED:
            splash_resource = files.ensure_resource(splash)
            async with splash_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;splash&#34;, future.result()))
                tasks.append(task)

        if banner is None:
            body.put(&#34;banner&#34;, None)
        elif banner is not undefined.UNDEFINED:
            banner_resource = files.ensure_resource(banner)
            async with banner_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;banner&#34;, future.result()))
                tasks.append(task)

        await asyncio.gather(*tasks)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_rest_guild(response)

    async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
        route = routes.DELETE_GUILD.compile(guild=guild)
        await self._request(route)

    async def fetch_guild_channels(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[channels.GuildChannel]:
        route = routes.GET_GUILD_CHANNELS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        channel_sequence = data_binding.cast_json_array(response, self._entity_factory.deserialize_channel)
        # Will always be guild channels unless Discord messes up severely on something!
        return typing.cast(&#34;typing.Sequence[channels.GuildChannel]&#34;, channel_sequence)

    async def create_guild_text_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildTextChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_TEXT,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        return typing.cast(channels.GuildTextChannel, channel)

    async def create_guild_news_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildNewsChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_NEWS,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        return typing.cast(channels.GuildNewsChannel, channel)

    async def create_guild_voice_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildVoiceChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_VOICE,
            position=position,
            user_limit=user_limit,
            bitrate=bitrate,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        return typing.cast(channels.GuildVoiceChannel, channel)

    async def create_guild_category(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildCategory:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_CATEGORY,
            position=position,
            permission_overwrites=permission_overwrites,
            reason=reason,
        )
        return typing.cast(channels.GuildCategory, channel)

    async def _create_guild_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        type_: channels.ChannelType,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildChannel:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, type_)
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user)
        body.put_snowflake(&#34;category_id&#34;, category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        channel = self._entity_factory.deserialize_channel(response)
        return typing.cast(channels.GuildChannel, channel)

    async def reposition_channels(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels.GuildChannel]],
    ) -&gt; None:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(channel)), &#34;position&#34;: pos} for pos, channel in positions.items()]
        await self._request(route, json=body)

    async def fetch_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.Member:
        route = routes.GET_GUILD_MEMBER.compile(guild=guild, user=user)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))

    def fetch_members(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; iterators.LazyIterator[guilds.Member]:
        return special_endpoints.MemberIterator(
            entity_factory=self._entity_factory, request_call=self._request, guild=guild
        )

    async def edit_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        voice_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if voice_channel is None:
            body.put(&#34;channel_id&#34;, None)
        elif voice_channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel_id&#34;, voice_channel)

        await self._request(route, json=body, reason=reason)

    async def edit_my_nick(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.Guild],
        nick: typing.Optional[str],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_MY_GUILD_NICKNAME.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        await self._request(route, json=body, reason=reason)

    async def add_role_to_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PUT_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def remove_role_from_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def kick_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    kick_member = kick_user

    async def ban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        delete_message_days: undefined.UndefinedNoneOr[int] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;delete_message_days&#34;, delete_message_days)
        # This endpoint specifies a reason in the body, specifically.
        body.put(&#34;reason&#34;, reason)
        route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, json=body)

    ban_member = ban_user

    async def unban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    unban_member = unban_user

    async def fetch_ban(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.GuildMemberBan:
        route = routes.GET_GUILD_BAN.compile(guild=guild, user=user)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_member_ban(response)

    async def fetch_bans(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[guilds.GuildMemberBan]:
        route = routes.GET_GUILD_BANS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_guild_member_ban)

    async def fetch_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Role]:
        route = routes.GET_GUILD_ROLES.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(
            response, self._entity_factory.deserialize_role, guild_id=snowflakes.Snowflake(guild)
        )

    async def create_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.count(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color)
        body.put(&#34;color&#34;, colour)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def reposition_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
    ) -&gt; None:
        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(role)), &#34;position&#34;: pos} for pos, role in positions.items()]
        await self._request(route, json=body)

    async def edit_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.count(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.PATCH_GUILD_ROLE.compile(guild=guild, role=role)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color)
        body.put(&#34;color&#34;, colour)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    ) -&gt; None:
        route = routes.DELETE_GUILD_ROLE.compile(guild=guild, role=role)
        await self._request(route)

    async def estimate_guild_prune_count(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
    ) -&gt; int:
        route = routes.GET_GUILD_PRUNE.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;days&#34;, days)
        if include_roles is not undefined.UNDEFINED:
            roles = &#34;,&#34;.join(str(int(role)) for role in include_roles)
            query.put(&#34;include_roles&#34;, roles)
        raw_response = await self._request(route, query=query)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return int(response[&#34;pruned&#34;])

    async def begin_guild_prune(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[int]:
        route = routes.POST_GUILD_PRUNE.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;days&#34;, days)
        body.put(&#34;compute_prune_count&#34;, compute_prune_count)
        body.put_snowflake_array(&#34;include_roles&#34;, include_roles)
        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        pruned = response.get(&#34;pruned&#34;)
        return int(pruned) if pruned is not None else None

    async def fetch_guild_voice_regions(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_GUILD_VOICE_REGIONS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_voice_region)

    async def fetch_guild_invites(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_GUILD_INVITES.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_invite_with_metadata)

    async def fetch_integrations(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Integration]:
        route = routes.GET_GUILD_INTEGRATIONS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_integration)

    async def edit_integration(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        integration: snowflakes.SnowflakeishOr[guilds.Integration],
        *,
        expire_behaviour: undefined.UndefinedOr[guilds.IntegrationExpireBehaviour] = undefined.UNDEFINED,
        expire_grace_period: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        enable_emojis: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_GUILD_INTEGRATION.compile(guild=guild, integration=integration)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;expire_behaviour&#34;, expire_behaviour)
        body.put(&#34;expire_grace_period&#34;, expire_grace_period, conversion=date.timespan_to_int)
        # Inconsistent naming in the API itself, so I have changed the name.
        body.put(&#34;enable_emoticons&#34;, enable_emojis)
        await self._request(route, json=body, reason=reason)

    async def delete_integration(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        integration: snowflakes.SnowflakeishOr[guilds.Integration],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_INTEGRATION.compile(guild=guild, integration=integration)
        await self._request(route, reason=reason)

    async def sync_integration(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        integration: snowflakes.SnowflakeishOr[guilds.Integration],
    ) -&gt; None:
        route = routes.POST_GUILD_INTEGRATION_SYNC.compile(guild=guild, integration=integration)
        await self._request(route)

    async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
        route = routes.GET_GUILD_WIDGET.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_widget(response)

    async def edit_widget(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels.GuildChannel]] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.GuildWidget:
        route = routes.PATCH_GUILD_WIDGET.compile(guild=guild)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;enabled&#34;, enabled)
        if channel is None:
            body.put(&#34;channel&#34;, None)
        elif channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel&#34;, channel)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_widget(response)

    async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
        route = routes.GET_GUILD_VANITY_URL.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_vanity_url(response)</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="BasicLazyCachedTCPConnectorFactory -- Lazy cached TCP connector factory." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory"
class='dotted'>BasicLazyCachedTCPConnectorFactory</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.rest.BasicLazyCachedTCPConnectorFactory" class="hljs python"><abbr title='A standard Python type.'>class</abbr> BasicLazyCachedTCPConnectorFactory (
    http_settings: <a href='../config.html#hikari.config.HTTPSettings'>config.HTTPSettings</a>,
): ...</code></pre>
<p>Lazy cached TCP connector factory.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L119-L137" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class BasicLazyCachedTCPConnectorFactory(rest_api.ConnectorFactory):
    &#34;&#34;&#34;Lazy cached TCP connector factory.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;connector&#34;, &#34;http_settings&#34;)

    def __init__(self, http_settings: config.HTTPSettings) -&gt; None:
        self.connector: typing.Optional[aiohttp.TCPConnector] = None
        self.http_settings = http_settings

    async def close(self) -&gt; None:
        if self.connector is not None:
            await self.connector.close()
            self.connector = None

    def acquire(self) -&gt; aiohttp.BaseConnector:
        if self.connector is None:
            self.connector = net.create_tcp_connector(self.http_settings)

        return self.connector</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="BasicLazyCachedTCPConnectorFactory -- Lazy cached TCP connector factory." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory"
class='dotted'>BasicLazyCachedTCPConnectorFactory</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="ConnectorFactory -- Provider of a connector." href="../api/rest.html#hikari.api.rest.ConnectorFactory"
class='dotted'>ConnectorFactory</a></dt>
<dd class="nested"><p>Provider of a connector.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
class='dotted'>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.acquire" class="hljs python"><abbr title='A standard Python function.'>def</abbr> acquire() -> aiohttp.connector.BaseConnector: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="ConnectorFactory -- Provider of a connector." href="../api/rest.html#hikari.api.rest.ConnectorFactory"
class='dotted'>ConnectorFactory</a></code>.<code><a title="acquire -- Acquire the connector." href="../api/rest.html#hikari.api.rest.ConnectorFactory.acquire"
class='dotted'>acquire</a></code>
</p>
<p>Acquire the connector.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L133-L137" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def acquire(self) -&gt; aiohttp.BaseConnector:
    if self.connector is None:
        self.connector = net.create_tcp_connector(self.http_settings)

    return self.connector</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.close" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> close() -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="ConnectorFactory -- Provider of a connector." href="../api/rest.html#hikari.api.rest.ConnectorFactory"
class='dotted'>ConnectorFactory</a></code>.<code><a title="close -- Close any resources if they exist." href="../api/rest.html#hikari.api.rest.ConnectorFactory.close"
class='dotted'>close</a></code>
</p>
<p>Close any resources if they exist.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L128-L131" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    if self.connector is not None:
        await self.connector.close()
        self.connector = None</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="connector -- Return an attribute of instance, which is of type owner." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.connector" id="hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.connector" class='dotted'>connector</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return an attribute of instance, which is of type owner." href="#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.http_settings" id="hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.http_settings" class='dotted'>http_settings</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTApp -- The base for a HTTP-only Discord application …" href="#hikari.impl.rest.RESTApp"
class='dotted'>RESTApp</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.rest.RESTApp" class="hljs python"><abbr title='A standard Python type.'>class</abbr> RESTApp (
    *,
    connector_factory: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../api/rest.html#hikari.api.rest.ConnectorFactory'>rest_api.ConnectorFactory</a>] = None,
    connector_owner: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = True,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
    http_settings: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.HTTPSettings'>config.HTTPSettings</a>] = None,
    proxy_settings: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.ProxySettings'>config.ProxySettings</a>] = None,
    url: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
): ...</code></pre>
<p>The base for a HTTP-only Discord application.</p>
<p>This comprises of a shared TCP connector connection pool, and can have
<code><a href='#hikari.impl.rest.RESTClientImpl'>RESTClientImpl</a></code> instances for specific credentials acquired
from it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>connector_factory</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[ConnectorFactory]</code></dt>
<dd>
<p>A factory that produces an <code><a href='https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.BaseConnector'>aiohttp.BaseConnector</a></code> when requested.</p>
<p>Defaults to a connector for a shared <code><a href='https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.TCPConnector'>aiohttp.TCPConnector</a></code> if
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</p>
<p>The connector factory is expected to handle providing locks around
resources and caching any result as desired.</p>
</dd>
<dt><strong><code>connector_owner</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>
<p>If you created the connector yourself, set this to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if
you want this component to destroy the connector once closed. Otherwise,
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> will prevent this and you will have to do this
manually. The latter is useful if you wish to maintain a shared
connection pool across your application with other non-Hikari
components.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you do not give a <code>connector_factory</code>, this will be IGNORED
and always be treated as <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> internally.</p>
</div>
</dd>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to use for blocking file IO operations. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>
is passed, then the default <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor'>concurrent.futures.ThreadPoolExecutor</a></code> for
the <code><a href='https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop'>AbstractEventLoop</a></code> will be used instead.</dd>
<dt><strong><code>http_settings</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a>]</code></dt>
<dd>HTTP settings to use. Sane defaults are used if this is
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><strong><code>proxy_settings</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a>]</code></dt>
<dd>Proxy settings to use. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then no proxy configuration
will be used.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The base URL for the API. You can generally leave this as being
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> and the correct default API base URL will be generated.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This event loop will be bound to a connector when the first call
to <code>acquire</code> is made.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L184-L339" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class RESTApp(traits.ExecutorAware):
    &#34;&#34;&#34;The base for a HTTP-only Discord application.

    This comprises of a shared TCP connector connection pool, and can have
    `RESTClientImpl` instances for specific credentials acquired
    from it.

    Parameters
    ----------
    connector_factory : typing.Optional[ConnectorFactory]
        A factory that produces an `aiohttp.BaseConnector` when requested.

        Defaults to a connector for a shared `aiohttp.TCPConnector` if
        `builtins.None`.

        The connector factory is expected to handle providing locks around
        resources and caching any result as desired.
    connector_owner : builtins.bool
        If you created the connector yourself, set this to `builtins.True` if
        you want this component to destroy the connector once closed. Otherwise,
        `builtins.False` will prevent this and you will have to do this
        manually. The latter is useful if you wish to maintain a shared
        connection pool across your application with other non-Hikari
        components.

        !!! warning
            If you do not give a `connector_factory`, this will be IGNORED
            and always be treated as `builtins.True` internally.
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking file IO operations. If `builtins.None`
        is passed, then the default `concurrent.futures.ThreadPoolExecutor` for
        the `asyncio.AbstractEventLoop` will be used instead.
    http_settings : typing.Optional[hikari.config.HTTPSettings]
        HTTP settings to use. Sane defaults are used if this is
        `builtins.None`.
    proxy_settings : typing.Optional[hikari.config.ProxySettings]
        Proxy settings to use. If `builtins.None` then no proxy configuration
        will be used.
    url : typing.Optional[builtins.str]
        The base URL for the API. You can generally leave this as being
        `builtins.None` and the correct default API base URL will be generated.

    !!! note
        This event loop will be bound to a connector when the first call
        to `acquire` is made.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_connector_factory&#34;,
        &#34;_connector_owner&#34;,
        &#34;_event_loop&#34;,
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_url&#34;,
    )

    def __init__(
        self,
        *,
        connector_factory: typing.Optional[rest_api.ConnectorFactory] = None,
        connector_owner: bool = True,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        http_settings: typing.Optional[config.HTTPSettings] = None,
        proxy_settings: typing.Optional[config.ProxySettings] = None,
        url: typing.Optional[str] = None,
    ) -&gt; None:
        self._http_settings = config.HTTPSettings() if http_settings is None else http_settings
        self._proxy_settings = config.ProxySettings() if proxy_settings is None else proxy_settings

        # Lazy initialized later, since we must initialize this in the event
        # loop we run the application from, otherwise aiohttp throws complaints
        # at us. Quart, amongst other libraries, causes issues with this by
        # making a new event loop on startup, which means if we initialised
        # the connector here and initialised this class in global scope, it
        # would potentially end up using the wrong event loop and aiohttp
        # would then fail when creating an HTTP request.
        if connector_factory is None:
            connector_factory = BasicLazyCachedTCPConnectorFactory(self._http_settings)
            connector_owner = True

        self._connector_factory = connector_factory
        self._connector_owner = connector_owner
        self._event_loop: typing.Optional[asyncio.AbstractEventLoop] = None
        self._executor = executor
        self._url = url

    @property
    def executor(self) -&gt; typing.Optional[concurrent.futures.Executor]:
        return self._executor

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    def acquire(self, token: str, token_type: str = _BEARER_TOKEN_PREFIX) -&gt; rest_api.RESTClient:
        loop = asyncio.get_running_loop()

        if self._event_loop is None:
            self._event_loop = loop

        if loop != self._event_loop:
            raise RuntimeError(&#34;Cannot use this object on a different event loop... please create a new instance.&#34;)

        # Since we essentially mimic a fake App instance, we need to make a circular provider.
        # We can achieve this using a lambda. This allows the entity factory to build models that
        # are also REST-aware
        cache = stateless_cache.StatelessCacheImpl()
        provider = _RESTProvider(
            lambda: entity_factory,
            self._executor,
            lambda: cache,
            lambda: rest_client,
        )
        entity_factory = entity_factory_impl.EntityFactoryImpl(provider)

        rest_client = RESTClientImpl(
            connector_factory=self._connector_factory,
            connector_owner=self._connector_owner,
            entity_factory=entity_factory,
            executor=self._executor,
            http_settings=self._http_settings,
            proxy_settings=self._proxy_settings,
            token=token,
            token_type=token_type,
            rest_url=self._url,
        )

        return rest_client

    async def close(self) -&gt; None:
        if self._connector_owner:
            await self._connector_factory.close()

    async def __aenter__(self) -&gt; RESTApp:
        return self

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self.close()

    def __enter__(self) -&gt; typing.NoReturn:
        # This is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

    def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
        return None</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTApp -- The base for a HTTP-only Discord application …" href="#hikari.impl.rest.RESTApp"
class='dotted'>RESTApp</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="ExecutorAware -- Structural supertype for an executor-aware object …" href="../traits.html#hikari.traits.ExecutorAware"
class='dotted'>ExecutorAware</a></dt>
<dd class="nested"><p>Structural supertype for an executor-aware object …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Protocol -- Base class for protocol classes …" href="https://docs.python.org/3/library/typing.html#typing.Protocol"
class='dotted'>Protocol</a></dt>
<dd class="nested"><p>Base class for protocol classes …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
class='dotted'>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.impl.rest.RESTApp.acquire" class="hljs python"><abbr title='A standard Python function.'>def</abbr> acquire(
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    token_type: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = 'Bearer',
) -> <a href='../api/rest.html#hikari.api.rest.RESTClient'>RESTClient</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L283-L316" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def acquire(self, token: str, token_type: str = _BEARER_TOKEN_PREFIX) -&gt; rest_api.RESTClient:
    loop = asyncio.get_running_loop()

    if self._event_loop is None:
        self._event_loop = loop

    if loop != self._event_loop:
        raise RuntimeError(&#34;Cannot use this object on a different event loop... please create a new instance.&#34;)

    # Since we essentially mimic a fake App instance, we need to make a circular provider.
    # We can achieve this using a lambda. This allows the entity factory to build models that
    # are also REST-aware
    cache = stateless_cache.StatelessCacheImpl()
    provider = _RESTProvider(
        lambda: entity_factory,
        self._executor,
        lambda: cache,
        lambda: rest_client,
    )
    entity_factory = entity_factory_impl.EntityFactoryImpl(provider)

    rest_client = RESTClientImpl(
        connector_factory=self._connector_factory,
        connector_owner=self._connector_owner,
        entity_factory=entity_factory,
        executor=self._executor,
        http_settings=self._http_settings,
        proxy_settings=self._proxy_settings,
        token=token,
        token_type=token_type,
        rest_url=self._url,
    )

    return rest_client</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTApp.close" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> close() -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L318-L320" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    if self._connector_owner:
        await self._connector_factory.close()</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="executor -- Return the executor to use for blocking operations …" href="#hikari.impl.rest.RESTApp.executor" id="hikari.impl.rest.RESTApp.executor" class='dotted'>executor</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></pre>
</dt>
<dd><p>Return the executor to use for blocking operations.</p>
<p>This may return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if the default <code><a href='https://docs.aiohttp.org/en/stable/glossary.html#term-asyncio'>asyncio</a></code> thread pool
should be used instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to use, or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> to use the <code><a href='https://docs.aiohttp.org/en/stable/glossary.html#term-asyncio'>asyncio</a></code> default
instead.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- " href="#hikari.impl.rest.RESTApp.http_settings" id="hikari.impl.rest.RESTApp.http_settings" class='dotted'>http_settings</a> : <a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></pre>
</dt>
<dd></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- " href="#hikari.impl.rest.RESTApp.proxy_settings" id="hikari.impl.rest.RESTApp.proxy_settings" class='dotted'>proxy_settings</a> : <a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></pre>
</dt>
<dd></dd>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClientImpl -- Implementation of the V6 and V7-compatible Discord HTTP API …" href="#hikari.impl.rest.RESTClientImpl"
class='dotted'>RESTClientImpl</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.rest.RESTClientImpl" class="hljs python"><abbr title='A standard Python type.'>class</abbr> RESTClientImpl (
    *,
    connector_factory: <a href='../api/rest.html#hikari.api.rest.ConnectorFactory'>rest_api.ConnectorFactory</a>,
    connector_owner: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>,
    entity_factory: entity_factory_.EntityFactory,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>],
    http_settings: <a href='../config.html#hikari.config.HTTPSettings'>config.HTTPSettings</a>,
    proxy_settings: <a href='../config.html#hikari.config.ProxySettings'>config.ProxySettings</a>,
    token: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    token_type: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
    rest_url: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
): ...</code></pre>
<p>Implementation of the V6 and V7-compatible Discord HTTP API.</p>
<p>This manages making HTTP/1.1 requests to the API and using the entity
factory within the passed application instance to deserialize JSON responses
to Pythonic data classes that are used throughout this library.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>connector_factory</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[ConnectorFactory]</code></dt>
<dd>
<p>A factory that produces an <code><a href='https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.BaseConnector'>aiohttp.BaseConnector</a></code> when requested.</p>
<p>Defaults to a connector for a shared <code><a href='https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.TCPConnector'>aiohttp.TCPConnector</a></code> if
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</p>
<p>The connector factory is expected to handle providing locks around
resources and caching any result as desired.</p>
</dd>
<dt><strong><code>connector_owner</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>If you created the connector yourself, set this to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if
you want this component to destroy the connector once closed. Otherwise,
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> will prevent this and you will have to do this
manually. The latter is useful if you wish to maintain a shared
connection pool across your application with other non-Hikari
components.</dd>
<dt><strong><code>entity_factory</code></strong> :&ensp;<code><a href='../api/entity_factory.html#hikari.api.entity_factory.EntityFactory'>EntityFactory</a></code></dt>
<dd>The entity factory to use.</dd>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to use for blocking IO. Defaults to the <code><a href='https://docs.aiohttp.org/en/stable/glossary.html#term-asyncio'>asyncio</a></code> thread
pool if set to <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The bot or bearer token. If no token is to be used,
this can be undefined.</dd>
<dt><strong><code>token_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The type of token in use. If no token is used, this can be ignored and
left to the default value. This can be <code>"Bot"</code> or <code>"Bearer"</code>.</dd>
<dt><strong><code>rest_url</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The HTTP API base URL. This can contain format-string specifiers to
interpolate information such as API version in use.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L342-L2332" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class RESTClientImpl(rest_api.RESTClient):
    &#34;&#34;&#34;Implementation of the V6 and V7-compatible Discord HTTP API.

    This manages making HTTP/1.1 requests to the API and using the entity
    factory within the passed application instance to deserialize JSON responses
    to Pythonic data classes that are used throughout this library.

    Parameters
    ----------
    connector_factory : typing.Optional[ConnectorFactory]
        A factory that produces an `aiohttp.BaseConnector` when requested.

        Defaults to a connector for a shared `aiohttp.TCPConnector` if
        `builtins.None`.

        The connector factory is expected to handle providing locks around
        resources and caching any result as desired.
    connector_owner : builtins.bool
        If you created the connector yourself, set this to `builtins.True` if
        you want this component to destroy the connector once closed. Otherwise,
        `builtins.False` will prevent this and you will have to do this
        manually. The latter is useful if you wish to maintain a shared
        connection pool across your application with other non-Hikari
        components.
    entity_factory : hikari.api.entity_factory.EntityFactory
        The entity factory to use.
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking IO. Defaults to the `asyncio` thread
        pool if set to `builtins.None`.
    token : hikari.undefined.UndefinedOr[builtins.str]
        The bot or bearer token. If no token is to be used,
        this can be undefined.
    token_type : hikari.undefined.UndefinedOr[builtins.str]
        The type of token in use. If no token is used, this can be ignored and
        left to the default value. This can be `&#34;Bot&#34;` or `&#34;Bearer&#34;`.
    rest_url : builtins.str
        The HTTP API base URL. This can contain format-string specifiers to
        interpolate information such as API version in use.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;buckets&#34;,
        &#34;global_rate_limit&#34;,
        &#34;_client_session&#34;,
        &#34;_closed_event&#34;,
        &#34;_connector_factory&#34;,
        &#34;_connector_owner&#34;,
        &#34;_entity_factory&#34;,
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_rest_url&#34;,
        &#34;_token&#34;,
    )

    buckets: buckets.RESTBucketManager
    &#34;&#34;&#34;Bucket ratelimiter manager.&#34;&#34;&#34;

    global_rate_limit: rate_limits.ManualRateLimiter
    &#34;&#34;&#34;Global ratelimiter.&#34;&#34;&#34;

    @attr.s(auto_exc=True, slots=True, repr=False, weakref_slot=False)
    class _RetryRequest(RuntimeError):
        ...

    def __init__(
        self,
        *,
        connector_factory: rest_api.ConnectorFactory,
        connector_owner: bool,
        entity_factory: entity_factory_.EntityFactory,
        executor: typing.Optional[concurrent.futures.Executor],
        http_settings: config.HTTPSettings,
        proxy_settings: config.ProxySettings,
        token: typing.Optional[str],
        token_type: typing.Optional[str] = None,
        rest_url: typing.Optional[str],
    ) -&gt; None:
        self.buckets = buckets.RESTBucketManager()
        # We&#39;ve been told in DAPI that this is per token.
        self.global_rate_limit = rate_limits.ManualRateLimiter()

        self._client_session: typing.Optional[aiohttp.ClientSession] = None
        self._closed_event = asyncio.Event()
        self._connector_factory = connector_factory
        self._connector_owner = connector_owner
        self._entity_factory = entity_factory
        self._executor = executor
        self._http_settings = http_settings
        self._proxy_settings = proxy_settings

        if token is None:
            full_token = None
        else:
            if token_type is None:
                token_type = _BOT_TOKEN_PREFIX

            full_token = f&#34;{token_type.title()} {token}&#34;

        self._token: typing.Optional[str] = full_token

        self._rest_url = rest_url if rest_url is not None else urls.REST_API_URL

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    @typing.final
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the HTTP client and any open HTTP connections.&#34;&#34;&#34;
        if self._client_session is not None:
            await self._client_session.close()
        await self._connector_factory.close()
        self.global_rate_limit.close()
        self.buckets.close()
        self._closed_event.set()
        # We have to sleep to allow aiohttp time to close SSL transports...
        # https://github.com/aio-libs/aiohttp/issues/1925
        # https://docs.aiohttp.org/en/stable/client_advanced.html#graceful-shutdown
        await asyncio.sleep(0.25)

    async def __aenter__(self) -&gt; RESTClientImpl:
        return self

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self.close()

    def __enter__(self) -&gt; typing.NoReturn:
        # This is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

    def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
        return None

    @typing.final
    def _acquire_client_session(self) -&gt; aiohttp.ClientSession:
        if self._client_session is None:
            self._closed_event.clear()
            self._client_session = net.create_client_session(
                connector=self._connector_factory.acquire(),
                # No, this is correct. We manage closing the connector ourselves in this class if we are
                # told we own it. This works around some other lifespan issues.
                connector_owner=False,
                http_settings=self._http_settings,
                raise_for_status=False,
                trust_env=self._proxy_settings.trust_env,
            )
            _LOGGER.log(ux.TRACE, &#34;acquired new aiohttp client session&#34;)

        elif self._client_session.closed:
            raise errors.HTTPClientClosedError

        return self._client_session

    @typing.final
    async def _request(
        self,
        compiled_route: routes.CompiledRoute,
        *,
        query: typing.Optional[data_binding.StringMapBuilder] = None,
        form: typing.Optional[aiohttp.FormData] = None,
        json: typing.Union[data_binding.JSONObjectBuilder, data_binding.JSONArray, None] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        no_auth: bool = False,
    ) -&gt; typing.Union[None, data_binding.JSONObject, data_binding.JSONArray]:
        # Make a ratelimit-protected HTTP request to a JSON endpoint and expect some form
        # of JSON response. If an error occurs, the response body is returned in the
        # raised exception as a bytes object. This is done since the differences between
        # the V6 and V7 API error messages are not documented properly, and there are
        # edge cases such as Cloudflare issues where we may receive arbitrary data in
        # the response instead of a JSON object.

        if not self.buckets.is_started:
            self.buckets.start()

        headers = data_binding.StringMapBuilder()
        headers.setdefault(_USER_AGENT_HEADER, _HTTP_USER_AGENT)
        headers.put(_X_RATELIMIT_PRECISION_HEADER, _MILLISECOND_PRECISION)

        if self._token is not None and not no_auth:
            headers[_AUTHORIZATION_HEADER] = self._token

        headers.put(_X_AUDIT_LOG_REASON_HEADER, reason)

        while True:
            try:
                url = compiled_route.create_url(self._rest_url)

                # Wait for any rate-limits to finish.
                await asyncio.gather(self.buckets.acquire(compiled_route), self.global_rate_limit.acquire())

                uuid = date.uuid()

                if _LOGGER.getEffectiveLevel() &lt;= ux.TRACE:
                    _LOGGER.log(
                        ux.TRACE,
                        &#34;%s %s %s\n%s&#34;,
                        uuid,
                        compiled_route.method,
                        url,
                        self._stringify_http_message(headers, json),
                    )

                # Make the request.
                session = self._acquire_client_session()
                start = date.monotonic()
                response = await session.request(
                    compiled_route.method,
                    url,
                    headers=headers,
                    params=query,
                    json=json,
                    data=form,
                    allow_redirects=self._http_settings.max_redirects is not None,
                    max_redirects=self._http_settings.max_redirects,
                    proxy=self._proxy_settings.url,
                    proxy_headers=self._proxy_settings.all_headers,
                )
                time_taken = (date.monotonic() - start) * 1_000

                if _LOGGER.getEffectiveLevel() &lt;= ux.TRACE:
                    _LOGGER.log(
                        ux.TRACE,
                        &#34;%s %s %s in %sms\n%s&#34;,
                        uuid,
                        response.status,
                        response.reason,
                        time_taken,
                        self._stringify_http_message(response.headers, await response.read()),
                    )

                # Ensure we are not rate limited, and update rate limiting headers where appropriate.
                await self._parse_ratelimits(compiled_route, response)

                # Don&#39;t bother processing any further if we got NO CONTENT. There&#39;s not anything
                # to check.
                if response.status == http.HTTPStatus.NO_CONTENT:
                    return None

                # Handle the response.
                if 200 &lt;= response.status &lt; 300:
                    if response.content_type == _APPLICATION_JSON:
                        # Only deserializing here stops Cloudflare shenanigans messing us around.
                        return data_binding.load_json(await response.read())

                    real_url = str(response.real_url)
                    raise errors.HTTPError(f&#34;Expected JSON [{response.content_type=}, {real_url=}]&#34;)

                await self._handle_error_response(response)

            except self._RetryRequest:
                continue

    @typing.final
    def _stringify_http_message(self, headers: data_binding.Headers, body: typing.Any) -&gt; str:
        string = &#34;\n&#34;.join(
            f&#34;    {name}: {value}&#34; if name != _AUTHORIZATION_HEADER else f&#34;    {name}: **REDACTED TOKEN**&#34;
            for name, value in headers.items()
        )

        if body is not None:
            string += &#34;\n\n    &#34;
            string += body.decode(&#34;ascii&#34;) if isinstance(body, bytes) else str(body)

        return string

    @staticmethod
    @typing.final
    async def _handle_error_response(response: aiohttp.ClientResponse) -&gt; typing.NoReturn:
        raise await net.generate_error_response(response)

    @typing.final
    async def _parse_ratelimits(self, compiled_route: routes.CompiledRoute, response: aiohttp.ClientResponse) -&gt; None:
        # Worth noting there is some bug on V6 that rate limits me immediately if I have an invalid token.
        # https://github.com/discord/discord-api-docs/issues/1569

        # Handle rate limiting.
        resp_headers = response.headers
        limit = int(resp_headers.get(_X_RATELIMIT_LIMIT_HEADER, &#34;1&#34;))
        remaining = int(resp_headers.get(_X_RATELIMIT_REMAINING_HEADER, &#34;1&#34;))
        bucket = resp_headers.get(_X_RATELIMIT_BUCKET_HEADER, &#34;None&#34;)
        reset_at = float(resp_headers.get(_X_RATELIMIT_RESET_HEADER, &#34;0&#34;))
        reset_after = float(resp_headers.get(_X_RATELIMIT_RESET_AFTER_HEADER, &#34;0&#34;))
        reset_date = datetime.datetime.fromtimestamp(reset_at, tz=datetime.timezone.utc)
        now_date = date.rfc7231_datetime_string_to_datetime(resp_headers[_DATE_HEADER])

        is_rate_limited = response.status == http.HTTPStatus.TOO_MANY_REQUESTS

        self.buckets.update_rate_limits(
            compiled_route=compiled_route,
            bucket_header=bucket,
            remaining_header=remaining,
            limit_header=limit,
            date_header=now_date,
            reset_at_header=reset_date,
        )

        if not is_rate_limited:
            return

        if response.content_type != _APPLICATION_JSON:
            # We don&#39;t know exactly what this could imply. It is likely Cloudflare interfering
            # but I&#39;d rather we just give up than do something resulting in multiple failed
            # requests repeatedly.
            raise errors.HTTPResponseError(
                str(response.real_url),
                http.HTTPStatus.TOO_MANY_REQUESTS,
                response.headers,
                await response.read(),
                f&#34;received rate limited response with unexpected response type {response.content_type}&#34;,
            )

        body = await response.json()
        body_retry_after = float(body[&#34;retry_after&#34;]) / 1_000

        if body.get(&#34;global&#34;, False) is True:
            self.global_rate_limit.throttle(body_retry_after)

            raise self._RetryRequest

        # Discord have started applying ratelimits to operations on some endpoints
        # based on specific fields used in the JSON body.
        # This does not get reflected in the headers. The first we know is when we
        # get a 429.
        # The issue is that we may get the same response if Discord dynamically
        # adjusts the bucket ratelimits.
        #
        # We have no mechanism for handing field-based ratelimits, so if we get
        # to here, but notice remaining is greater than zero, we should just error.
        #
        # Worth noting we still ignore the retry_after in the body. I have no clue
        # if there is some weird edge case where a bucket rate limit can occur on
        # top of a non-global one, but in this case this check will misbehave and
        # instead of erroring, will trigger a backoff that might be 10 minutes or
        # more...
        #
        # Seems Discord may raise this on some other undocumented cases, which
        # is nice of them. Apparently some dude spamming slurs in the Python
        # guild via a leaked webhook URL made people&#39;s clients exhibit this
        # behaviour.

        # I realise remaining should never be less than zero, but quite frankly, I don&#39;t
        # trust that voodoo type stuff will not ever occur with that value from them...
        if remaining &lt;= 0:
            # We can retry and we will then abide by the updated bucket ratelimits.
            _LOGGER.debug(
                &#34;rate-limited on bucket %s at %s. This is a bucket discrepancy, so we will retry at %s&#34;,
                bucket,
                compiled_route,
                reset_date,
            )

        # If the values are within 20% of eachother by relativistic tolerance, it is probably
        # safe to retry the request, as they are likely the same value just with some
        # measuring difference. 20% was used as a rounded figure.
        if math.isclose(body_retry_after, reset_after, rel_tol=0.20):
            raise self._RetryRequest

        raise errors.RateLimitedError(
            url=str(response.real_url),
            route=compiled_route,
            headers=response.headers,
            raw_body=body,
            retry_after=body_retry_after,
        )

    @staticmethod
    @typing.final
    def _generate_allowed_mentions(
        mentions_everyone: undefined.UndefinedOr[bool],
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ],
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ],
    ) -&gt; data_binding.JSONObject:
        parsed_mentions: typing.List[str] = []
        allowed_mentions = {&#34;parse&#34;: parsed_mentions}

        if mentions_everyone is True:
            parsed_mentions.append(&#34;everyone&#34;)

        if user_mentions is True:
            parsed_mentions.append(&#34;users&#34;)
        elif isinstance(user_mentions, typing.Collection):
            # Duplicates will cause discord to error.
            ids = {str(int(u)) for u in user_mentions}
            allowed_mentions[&#34;users&#34;] = list(ids)

        if role_mentions is True:
            parsed_mentions.append(&#34;roles&#34;)
        elif isinstance(role_mentions, typing.Collection):
            # Duplicates will cause discord to error.
            ids = {str(int(r)) for r in role_mentions}
            allowed_mentions[&#34;roles&#34;] = list(ids)

        return allowed_mentions

    async def fetch_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]
    ) -&gt; channels.PartialChannel:
        route = routes.GET_CHANNEL.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_channel(response)

    async def edit_channel(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        /,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        parent_category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.PartialChannel:
        route = routes.PATCH_CHANNEL.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user)
        body.put_snowflake(&#34;parent_id&#34;, parent_category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_channel(response)

    async def follow_channel(
        self,
        news_channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        target_channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.ChannelFollow:
        route = routes.POST_CHANNEL_FOLLOWERS.compile(channel=news_channel)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;webhook_channel_id&#34;, target_channel)

        raw_response = await self._request(route, json=body, reason=reason)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_channel_follow(response)

    async def delete_channel(self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]) -&gt; None:
        route = routes.DELETE_CHANNEL.compile(channel=channel)
        await self._request(route)

    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: typing.Union[
            snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels.PermissionOverwrite
        ],
        *,
        target_type: undefined.UndefinedOr[typing.Union[channels.PermissionOverwriteType, str]] = undefined.UNDEFINED,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if target_type is undefined.UNDEFINED:
            if isinstance(target, users.PartialUser):
                target_type = channels.PermissionOverwriteType.MEMBER
            elif isinstance(target, guilds.Role):
                target_type = channels.PermissionOverwriteType.ROLE
            elif isinstance(target, channels.PermissionOverwrite):
                target_type = target.type
            else:
                raise TypeError(
                    &#34;Cannot determine the type of the target to update. Try specifying &#39;target_type&#39; manually.&#34;
                )

        route = routes.PATCH_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, target_type)
        body.put(&#34;allow&#34;, allow)
        body.put(&#34;deny&#34;, deny)

        await self._request(route, json=body, reason=reason)

    async def delete_permission_overwrite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: snowflakes.SnowflakeishOr[
            typing.Union[channels.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
        ],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        await self._request(route)

    async def fetch_channel_invites(
        self, channel: snowflakes.SnowflakeishOr[channels.GuildChannel]
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_CHANNEL_INVITES.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_invite_with_metadata)

    async def create_invite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        *,
        max_age: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        target_user_type: undefined.UndefinedOr[invites.TargetUserType] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        route = routes.POST_CHANNEL_INVITES.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;max_age&#34;, max_age, conversion=date.timespan_to_int)
        body.put(&#34;max_uses&#34;, max_uses)
        body.put(&#34;temporary&#34;, temporary)
        body.put(&#34;unique&#34;, unique)
        body.put_snowflake(&#34;target_user_id&#34;, target_user)
        body.put(&#34;target_user_type&#34;, target_user_type)
        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_invite_with_metadata(response)

    def trigger_typing(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; special_endpoints.TypingIndicator:
        return special_endpoints.TypingIndicator(
            request_call=self._request, channel=channel, rest_closed_event=self._closed_event
        )

    async def fetch_pins(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; typing.Sequence[messages_.Message]:
        route = routes.GET_CHANNEL_PINS.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_message)

    async def pin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.PUT_CHANNEL_PINS.compile(channel=channel, message=message)
        await self._request(route)

    async def unpin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PIN.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[messages_.Message]:
        if undefined.count(before, after, around) &lt; 2:
            raise TypeError(&#34;Expected no kwargs, or maximum of one of &#39;before&#39;, &#39;after&#39;, &#39;around&#39;&#34;)

        timestamp: undefined.UndefinedOr[str]

        if before is not undefined.UNDEFINED:
            direction = &#34;before&#34;
            if isinstance(before, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(before))
            else:
                timestamp = str(int(before))
        elif after is not undefined.UNDEFINED:
            direction = &#34;after&#34;
            if isinstance(after, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(after))
            else:
                timestamp = str(int(after))
        elif around is not undefined.UNDEFINED:
            direction = &#34;around&#34;
            if isinstance(around, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(around))
            else:
                timestamp = str(int(around))
        else:
            direction = &#34;before&#34;
            timestamp = undefined.UNDEFINED

        return special_endpoints.MessageIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            direction=direction,
            first_id=timestamp,
        )

    async def fetch_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; messages_.Message:
        route = routes.GET_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def create_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        if not undefined.count(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not isinstance(attachments, typing.Collection) and attachments is not undefined.UNDEFINED:
            raise ValueError(
                &#34;You passed a non-collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        route = routes.POST_CHANNEL_MESSAGES.compile(channel=channel)

        if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
            # Syntatic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        elif undefined.count(attachment, attachments) == 2 and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntatic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;allowed_mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions))
        body.put(&#34;content&#34;, content, conversion=str)
        body.put(&#34;nonce&#34;, nonce)
        body.put(&#34;tts&#34;, tts)

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []

        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        if embed is not undefined.UNDEFINED:
            embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
            body.put(&#34;embed&#34;, embed_payload)
            final_attachments.extend(embed_attachments)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()

            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=_APPLICATION_OCTET_STREAM)

                raw_response = await self._request(route, form=form)
            finally:
                await stack.aclose()
        else:
            raw_response = await self._request(route, json=body)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def create_crossposts(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; messages_.Message:
        route = routes.POST_CHANNEL_CROSSPOST.compile(channel=channel, message=message)

        raw_response = await self._request(route)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def edit_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
        flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.PATCH_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;flags&#34;, flags)
        if undefined.count(mentions_everyone, user_mentions, role_mentions) != 3:
            body.put(
                &#34;allowed_mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions)
            )

        if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
            # Syntatic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        if content is not None:
            body.put(&#34;content&#34;, content, conversion=str)
        else:
            body.put(&#34;content&#34;, None)

        if isinstance(embed, embeds_.Embed):
            embed_payload, _ = self._entity_factory.serialize_embed(embed)
            body.put(&#34;embed&#34;, embed_payload)
        elif embed is None:
            body.put(&#34;embed&#34;, None)

        raw_response = await self._request(route, json=body)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def delete_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        await self._request(route)

    async def delete_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        /,
        *messages: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.POST_DELETE_CHANNEL_MESSAGES_BULK.compile(channel=channel)

        pending: typing.Deque[snowflakes.SnowflakeishOr[messages_.Message]] = collections.deque(messages)
        deleted: typing.Deque[snowflakes.SnowflakeishOr[messages_.Message]] = collections.deque()

        while pending:
            # Discord only allows 2-100 messages in the BULK_DELETE endpoint. Because of that,
            # if the user wants 101 messages deleted, we will post 100 messages in bulk delete
            # and then the last message in a normal delete.
            # Along with this, the bucket size for v6 and v7 seems to be a bit restrictive. As of
            # 30th July 2020, this endpoint returned the following headers when being ratelimited:
            #       x-ratelimit-bucket         b05c0d8c2ab83895085006a8eae073a3
            #       x-ratelimit-limit          1
            #       x-ratelimit-remaining      0
            #       x-ratelimit-reset          1596033974.096
            #       x-ratelimit-reset-after    3.000
            # This kind of defeats the point of asynchronously gathering any of these
            # in the first place really. To save clogging up the event loop
            # (albeit at a cost of maybe a couple-dozen milliseconds per call),
            # I am just gonna invoke these sequentially instead.
            try:
                if len(pending) == 1:
                    message = pending.popleft()
                    await self.delete_message(channel, message)
                    deleted.append(message)
                else:
                    body = data_binding.JSONObjectBuilder()
                    chunk = [pending.popleft() for _ in range(min(100, len(pending)))]
                    body.put_snowflake_array(&#34;messages&#34;, chunk)
                    await self._request(route, json=body)
                    deleted += chunk
            except Exception as ex:
                raise errors.BulkDeleteError(deleted, pending) from ex

    # Custom emoji mentions are in the format of &lt;:name:id&gt; for static emoji, or
    # &lt;a:name:id&gt; for animated emoji.
    _CUSTOM_EMOJI_PATTERN: typing.Final[typing.ClassVar[re.Pattern[str]]] = re.compile(r&#34;&lt;a?:([^:]+:\d+)&gt;&#34;)

    def _transform_emoji_to_url_format(self, emoji: emojis.Emojiish) -&gt; str:
        # Given an emojiish, check if it is a valid custom emoji mention. If it
        # is, then convert it to the name:id format (remove the wrapping
        # characters), then return it. If the emoji is an emojis.CustomEmoji
        # directly, then get the url_name of it. All other emojis and objects
        # can just be cast to string, as they are probably unicode emoji objects
        # or unicode emoji strings.
        if isinstance(emoji, emojis.CustomEmoji):
            return emoji.url_name

        if isinstance(emoji, str) and (custom_mention_match := self._CUSTOM_EMOJI_PATTERN.match(emoji)) is not None:
            # False positive in PyCharm, yet again.
            return custom_mention_match.group(1)

        return str(emoji)

    async def add_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        route = routes.PUT_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_my_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        route = routes.DELETE_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_all_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        route = routes.DELETE_REACTION_EMOJI.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; None:
        route = routes.DELETE_REACTION_USER.compile(
            emoji=self._transform_emoji_to_url_format(emoji),
            channel=channel,
            message=message,
            user=user,
        )
        await self._request(route)

    async def delete_all_reactions(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        route = routes.DELETE_ALL_REACTIONS.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.Message],
        emoji: emojis.Emojiish,
    ) -&gt; iterators.LazyIterator[users.User]:
        return special_endpoints.ReactorIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            message=message,
            emoji=self._transform_emoji_to_url_format(emoji),
        )

    async def create_webhook(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        name: str,
        *,
        avatar: typing.Optional[files.Resourceish] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        route = routes.POST_CHANNEL_WEBHOOKS.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)

        if avatar is not None:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_webhook(response)

    async def fetch_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        if token is undefined.UNDEFINED:
            route = routes.GET_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.GET_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        raw_response = await self._request(route, no_auth=no_auth)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_webhook(response)

    async def fetch_channel_webhooks(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        route = routes.GET_CHANNEL_WEBHOOKS.compile(channel=channel)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_webhook)

    async def fetch_guild_webhooks(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        route = routes.GET_GUILD_WEBHOOKS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_webhook)

    async def edit_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.TextChannel]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        if token is undefined.UNDEFINED:
            route = routes.PATCH_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.PATCH_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake(&#34;channel&#34;, channel)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        raw_response = await self._request(route, json=body, reason=reason, no_auth=no_auth)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_webhook(response)

    async def delete_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if token is undefined.UNDEFINED:
            route = routes.DELETE_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.DELETE_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        await self._request(route, no_auth=no_auth)

    async def execute_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        token: str,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        if not undefined.count(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not undefined.count(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if not isinstance(embeds, typing.Collection) and embeds is not undefined.UNDEFINED:
            raise TypeError(
                &#34;You passed a non collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if not isinstance(attachments, typing.Collection) and attachments is not undefined.UNDEFINED:
            raise TypeError(
                &#34;You passed a non collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        if undefined.count(embed, embeds) == 2 and isinstance(content, embeds_.Embed):
            # Syntatic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        elif undefined.count(attachment, attachments) == 2 and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntatic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        route = routes.POST_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []
        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        serialized_embeds: data_binding.JSONArray = []

        if embeds is not undefined.UNDEFINED:
            for embed in embeds:
                embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                serialized_embeds.append(embed_payload)
                final_attachments.extend(embed_attachments)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions))
        body.put(&#34;content&#34;, content, conversion=str)
        body.put(&#34;embeds&#34;, serialized_embeds)
        body.put(&#34;username&#34;, username)
        body.put(&#34;avatar_url&#34;, avatar_url)
        body.put(&#34;tts&#34;, tts)
        query = data_binding.StringMapBuilder()
        query.put(&#34;wait&#34;, True)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()

            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=_APPLICATION_OCTET_STREAM)

                raw_response = await self._request(route, query=query, form=form, no_auth=True)
            finally:
                await stack.aclose()
        else:
            raw_response = await self._request(route, query=query, json=body, no_auth=True)

        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_message(response)

    async def fetch_gateway_url(self) -&gt; str:
        route = routes.GET_GATEWAY.compile()
        # This doesn&#39;t need authorization.
        raw_response = await self._request(route, no_auth=True)
        response = typing.cast(&#34;typing.Mapping[str, str]&#34;, raw_response)
        return response[&#34;url&#34;]

    async def fetch_gateway_bot(self) -&gt; sessions.GatewayBot:
        route = routes.GET_GATEWAY_BOT.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_gateway_bot(response)

    async def fetch_invite(self, invite: invites.Inviteish) -&gt; invites.Invite:
        route = routes.GET_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        raw_response = await self._request(route, query=query)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_invite(response)

    async def delete_invite(self, invite: invites.Inviteish) -&gt; None:
        route = routes.DELETE_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        await self._request(route)

    async def fetch_my_user(self) -&gt; users.OwnUser:
        route = routes.GET_MY_USER.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_my_user(response)

    async def edit_my_user(
        self,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; users.OwnUser:
        route = routes.PATCH_MY_USER.compile()
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;username&#34;, username)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        raw_response = await self._request(route, json=body)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_my_user(response)

    async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
        route = routes.GET_MY_CONNECTIONS.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_own_connection)

    def fetch_my_guilds(
        self,
        *,
        newest_first: bool = False,
        start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[applications.OwnGuild]:
        if start_at is undefined.UNDEFINED:
            start_at = snowflakes.Snowflake.max() if newest_first else snowflakes.Snowflake.min()
        elif isinstance(start_at, datetime.datetime):
            start_at = snowflakes.Snowflake.from_datetime(start_at)
        else:
            start_at = int(start_at)

        return special_endpoints.OwnGuildIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            newest_first=newest_first,
            first_id=str(start_at),
        )

    async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
        route = routes.DELETE_MY_GUILD.compile(guild=guild)
        await self._request(route)

    async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels.DMChannel:
        route = routes.POST_MY_CHANNELS.compile()
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;recipient_id&#34;, user)
        raw_response = await self._request(route, json=body)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_dm(response)

    async def fetch_application(self) -&gt; applications.Application:
        route = routes.GET_MY_APPLICATION.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_application(response)

    async def add_user_to_guild(
        self,
        access_token: str,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[guilds.Member]:
        route = routes.PUT_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;access_token&#34;, access_token)
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if (raw_response := await self._request(route, json=body)) is not None:
            response = typing.cast(data_binding.JSONObject, raw_response)
            return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))
        else:
            # User already is in the guild.
            return None

    async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_VOICE_REGIONS.compile()
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_voice_region)

    async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
        route = routes.GET_USER.compile(user=user)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_user(response)

    def fetch_audit_log(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        event_type: undefined.UndefinedOr[audit_logs.AuditLogEventType] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:

        timestamp: undefined.UndefinedOr[str]
        if before is undefined.UNDEFINED:
            timestamp = undefined.UNDEFINED
        elif isinstance(before, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(before))
        else:
            timestamp = str(int(before))

        return special_endpoints.AuditLogIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            guild=guild,
            before=timestamp,
            user=user,
            action_type=event_type,
        )

    async def fetch_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
        # likewise this only is valid for custom emojis, unicode emojis make little sense here.
        emoji: typing.Union[str, emojis.CustomEmoji],
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.GET_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def fetch_guild_emojis(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
        route = routes.GET_GUILD_EMOJIS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(
            response, self._entity_factory.deserialize_known_custom_emoji, guild_id=snowflakes.Snowflake(guild)
        )

    async def create_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        image: files.Resourceish,
        *,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.POST_GUILD_EMOJIS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        image_resource = files.ensure_resource(image)
        async with image_resource.stream(executor=self._executor) as stream:
            body.put(&#34;image&#34;, await stream.data_uri())

        body.put_snowflake_array(&#34;roles&#34;, roles)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def edit_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
        # likewise this only is valid for custom emojis, unicode emojis make little sense here.
        emoji: typing.Union[str, emojis.CustomEmoji],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.PATCH_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
        # likewise this only is valid for custom emojis, unicode emojis make little sense here.
        emoji: typing.Union[str, emojis.CustomEmoji],
    ) -&gt; None:
        route = routes.DELETE_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
        await self._request(route)

    def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
        return special_endpoints.GuildBuilder(
            entity_factory=self._entity_factory, executor=self._executor, request_call=self._request, name=name
        )

    async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
        route = routes.GET_GUILD.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        raw_response = await self._request(route, query=query)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_rest_guild(response)

    async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
        route = routes.GET_GUILD_PREVIEW.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_preview(response)

    async def edit_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[voices.VoiceRegionish] = undefined.UNDEFINED,
        verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
        default_message_notifications: undefined.UndefinedOr[
            guilds.GuildMessageNotificationsLevel
        ] = undefined.UNDEFINED,
        explicit_content_filter_level: undefined.UndefinedOr[
            guilds.GuildExplicitContentFilterLevel
        ] = undefined.UNDEFINED,
        afk_channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]] = undefined.UNDEFINED,
        afk_timeout: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        system_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        rules_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        public_updates_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        route = routes.PATCH_GUILD.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;region&#34;, region, conversion=str)
        body.put(&#34;verification&#34;, verification_level)
        body.put(&#34;notifications&#34;, default_message_notifications)
        body.put(&#34;explicit_content_filter&#34;, explicit_content_filter_level)
        body.put(&#34;afk_timeout&#34;, afk_timeout)
        body.put(&#34;preferred_locale&#34;, preferred_locale, conversion=str)
        body.put_snowflake(&#34;afk_channel_id&#34;, afk_channel)
        body.put_snowflake(&#34;owner_id&#34;, owner)
        body.put_snowflake(&#34;system_channel_id&#34;, system_channel)
        body.put_snowflake(&#34;rules_channel_id&#34;, rules_channel)
        body.put_snowflake(&#34;public_updates_channel_id&#34;, public_updates_channel)

        tasks: typing.List[asyncio.Task[str]] = []

        if icon is None:
            body.put(&#34;icon&#34;, None)
        elif icon is not undefined.UNDEFINED:
            icon_resource = files.ensure_resource(icon)
            async with icon_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;icon&#34;, future.result()))
                tasks.append(task)

        if splash is None:
            body.put(&#34;splash&#34;, None)
        elif splash is not undefined.UNDEFINED:
            splash_resource = files.ensure_resource(splash)
            async with splash_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;splash&#34;, future.result()))
                tasks.append(task)

        if banner is None:
            body.put(&#34;banner&#34;, None)
        elif banner is not undefined.UNDEFINED:
            banner_resource = files.ensure_resource(banner)
            async with banner_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;banner&#34;, future.result()))
                tasks.append(task)

        await asyncio.gather(*tasks)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_rest_guild(response)

    async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
        route = routes.DELETE_GUILD.compile(guild=guild)
        await self._request(route)

    async def fetch_guild_channels(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[channels.GuildChannel]:
        route = routes.GET_GUILD_CHANNELS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        channel_sequence = data_binding.cast_json_array(response, self._entity_factory.deserialize_channel)
        # Will always be guild channels unless Discord messes up severely on something!
        return typing.cast(&#34;typing.Sequence[channels.GuildChannel]&#34;, channel_sequence)

    async def create_guild_text_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildTextChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_TEXT,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        return typing.cast(channels.GuildTextChannel, channel)

    async def create_guild_news_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildNewsChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_NEWS,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        return typing.cast(channels.GuildNewsChannel, channel)

    async def create_guild_voice_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildVoiceChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_VOICE,
            position=position,
            user_limit=user_limit,
            bitrate=bitrate,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        return typing.cast(channels.GuildVoiceChannel, channel)

    async def create_guild_category(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildCategory:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels.ChannelType.GUILD_CATEGORY,
            position=position,
            permission_overwrites=permission_overwrites,
            reason=reason,
        )
        return typing.cast(channels.GuildCategory, channel)

    async def _create_guild_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        type_: channels.ChannelType,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildChannel:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, type_)
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user)
        body.put_snowflake(&#34;category_id&#34;, category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        channel = self._entity_factory.deserialize_channel(response)
        return typing.cast(channels.GuildChannel, channel)

    async def reposition_channels(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels.GuildChannel]],
    ) -&gt; None:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(channel)), &#34;position&#34;: pos} for pos, channel in positions.items()]
        await self._request(route, json=body)

    async def fetch_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.Member:
        route = routes.GET_GUILD_MEMBER.compile(guild=guild, user=user)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))

    def fetch_members(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; iterators.LazyIterator[guilds.Member]:
        return special_endpoints.MemberIterator(
            entity_factory=self._entity_factory, request_call=self._request, guild=guild
        )

    async def edit_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        voice_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if voice_channel is None:
            body.put(&#34;channel_id&#34;, None)
        elif voice_channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel_id&#34;, voice_channel)

        await self._request(route, json=body, reason=reason)

    async def edit_my_nick(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.Guild],
        nick: typing.Optional[str],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_MY_GUILD_NICKNAME.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        await self._request(route, json=body, reason=reason)

    async def add_role_to_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PUT_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def remove_role_from_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def kick_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    kick_member = kick_user

    async def ban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        delete_message_days: undefined.UndefinedNoneOr[int] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;delete_message_days&#34;, delete_message_days)
        # This endpoint specifies a reason in the body, specifically.
        body.put(&#34;reason&#34;, reason)
        route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, json=body)

    ban_member = ban_user

    async def unban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    unban_member = unban_user

    async def fetch_ban(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.GuildMemberBan:
        route = routes.GET_GUILD_BAN.compile(guild=guild, user=user)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_member_ban(response)

    async def fetch_bans(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[guilds.GuildMemberBan]:
        route = routes.GET_GUILD_BANS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_guild_member_ban)

    async def fetch_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Role]:
        route = routes.GET_GUILD_ROLES.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(
            response, self._entity_factory.deserialize_role, guild_id=snowflakes.Snowflake(guild)
        )

    async def create_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.count(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color)
        body.put(&#34;color&#34;, colour)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def reposition_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
    ) -&gt; None:
        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(role)), &#34;position&#34;: pos} for pos, role in positions.items()]
        await self._request(route, json=body)

    async def edit_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.count(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.PATCH_GUILD_ROLE.compile(guild=guild, role=role)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color)
        body.put(&#34;color&#34;, colour)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    ) -&gt; None:
        route = routes.DELETE_GUILD_ROLE.compile(guild=guild, role=role)
        await self._request(route)

    async def estimate_guild_prune_count(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
    ) -&gt; int:
        route = routes.GET_GUILD_PRUNE.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;days&#34;, days)
        if include_roles is not undefined.UNDEFINED:
            roles = &#34;,&#34;.join(str(int(role)) for role in include_roles)
            query.put(&#34;include_roles&#34;, roles)
        raw_response = await self._request(route, query=query)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return int(response[&#34;pruned&#34;])

    async def begin_guild_prune(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[int]:
        route = routes.POST_GUILD_PRUNE.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;days&#34;, days)
        body.put(&#34;compute_prune_count&#34;, compute_prune_count)
        body.put_snowflake_array(&#34;include_roles&#34;, include_roles)
        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        pruned = response.get(&#34;pruned&#34;)
        return int(pruned) if pruned is not None else None

    async def fetch_guild_voice_regions(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_GUILD_VOICE_REGIONS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_voice_region)

    async def fetch_guild_invites(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_GUILD_INVITES.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_invite_with_metadata)

    async def fetch_integrations(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Integration]:
        route = routes.GET_GUILD_INTEGRATIONS.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONArray, raw_response)
        return data_binding.cast_json_array(response, self._entity_factory.deserialize_integration)

    async def edit_integration(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        integration: snowflakes.SnowflakeishOr[guilds.Integration],
        *,
        expire_behaviour: undefined.UndefinedOr[guilds.IntegrationExpireBehaviour] = undefined.UNDEFINED,
        expire_grace_period: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
        enable_emojis: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_GUILD_INTEGRATION.compile(guild=guild, integration=integration)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;expire_behaviour&#34;, expire_behaviour)
        body.put(&#34;expire_grace_period&#34;, expire_grace_period, conversion=date.timespan_to_int)
        # Inconsistent naming in the API itself, so I have changed the name.
        body.put(&#34;enable_emoticons&#34;, enable_emojis)
        await self._request(route, json=body, reason=reason)

    async def delete_integration(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        integration: snowflakes.SnowflakeishOr[guilds.Integration],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_INTEGRATION.compile(guild=guild, integration=integration)
        await self._request(route, reason=reason)

    async def sync_integration(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        integration: snowflakes.SnowflakeishOr[guilds.Integration],
    ) -&gt; None:
        route = routes.POST_GUILD_INTEGRATION_SYNC.compile(guild=guild, integration=integration)
        await self._request(route)

    async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
        route = routes.GET_GUILD_WIDGET.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_widget(response)

    async def edit_widget(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels.GuildChannel]] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.GuildWidget:
        route = routes.PATCH_GUILD_WIDGET.compile(guild=guild)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;enabled&#34;, enabled)
        if channel is None:
            body.put(&#34;channel&#34;, None)
        elif channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel&#34;, channel)

        raw_response = await self._request(route, json=body, reason=reason)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_guild_widget(response)

    async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
        route = routes.GET_GUILD_VANITY_URL.compile(guild=guild)
        raw_response = await self._request(route)
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_vanity_url(response)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClientImpl -- Implementation of the V6 and V7-compatible Discord HTTP API …" href="#hikari.impl.rest.RESTClientImpl"
class='dotted'>RESTClientImpl</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></dt>
<dd class="nested"><p>Interface for functionality that a REST API implementation provides.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="NetworkSettingsAware -- Structural supertype for any component aware of network settings." href="../traits.html#hikari.traits.NetworkSettingsAware"
class='dotted'>NetworkSettingsAware</a></dt>
<dd class="nested"><p>Structural supertype for any component aware of network settings.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Protocol -- Base class for protocol classes …" href="https://docs.python.org/3/library/typing.html#typing.Protocol"
class='dotted'>Protocol</a></dt>
<dd class="nested"><p>Base class for protocol classes …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
class='dotted'>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
class='dotted'>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.add_reaction" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> add_reaction(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="add_reaction -- Add a reaction emoji to a message in a given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.add_reaction"
class='dotted'>add_reaction</a></code>
</p>
<p>Add a reaction emoji to a message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to add the reaction to is. This
may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an existing
channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to add a reaction to. This may be a
<code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to react to the message with.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>ADD_REACTIONS</code> (this is only necessary if you
are the first person to add the reaction).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1183-L1194" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def add_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
    emoji: emojis.Emojiish,
) -&gt; None:
    route = routes.PUT_MY_REACTION.compile(
        emoji=self._transform_emoji_to_url_format(emoji),
        channel=channel,
        message=message,
    )
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.add_role_to_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> add_role_to_member(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2031-L2040" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def add_role_to_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PUT_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.add_user_to_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> add_user_to_guild(
    access_token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    nick: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    mute: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    deaf: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> Union[<a href='../guilds.html#hikari.guilds.Member'>Member</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="add_user_to_guild -- Add a user to a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.add_user_to_guild"
class='dotted'>add_user_to_guild</a></code>
</p>
<p>Add a user to a guild.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This requires the <code>access_token</code> to have the
<code><a href='../applications.html#hikari.applications.OAuth2Scope.GUILDS_JOIN'>GUILDS_JOIN</a></code> scope enabled.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to add the user to. This can be a <code><a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a></code>
or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html'>hikari.users.PartialGuild</a>]</code></dt>
<dd>The user to add to the guild. This can be a <code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code>
or the ID of an existing user.</dd>
<dt><strong><code>nick</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>
<p>If specified, the nick to add to the user when he joins the guild.</p>
<p>Requires the <code>MANAGE_NICKNAMES</code> permission on the guild.</p>
</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>
<p>If specified, the roles to add to the user when he joins the guild.
This can be a collection of <code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> or of IDs.</p>
<p>Requires the <code>MANAGE_ROLES</code> permission on the guild.</p>
</dd>
<dt><strong><code>mute</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If specified, the mute state to add the user when he joins the guild.</p>
<p>Requires the <code>MUTE_MEMBERS</code> permission on the guild.</p>
</dd>
<dt><strong><code>deaf</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If specified, the deaf state to add the user when he joins the guild.</p>
<p>Requires the <code>DEAFEN_MEMBERS</code> permission on the guild.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd><code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if the user was already part of the guild, else
<code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild you want to add the user to,
if you are missing permissions to do one of the things you specified,
if you are using an access token for another user, if the token is
bound to annother bot or if the access token doesnt have the
<code><a href='../applications.html#hikari.applications.OAuth2Scope.GUILDS_JOIN'>GUILDS_JOIN</a></code> scope enabled.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If you own the guild or the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1559-L1585" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def add_user_to_guild(
    self,
    access_token: str,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
) -&gt; typing.Optional[guilds.Member]:
    route = routes.PUT_GUILD_MEMBER.compile(guild=guild, user=user)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;access_token&#34;, access_token)
    body.put(&#34;nick&#34;, nick)
    body.put(&#34;mute&#34;, mute)
    body.put(&#34;deaf&#34;, deaf)
    body.put_snowflake_array(&#34;roles&#34;, roles)

    if (raw_response := await self._request(route, json=body)) is not None:
        response = typing.cast(data_binding.JSONObject, raw_response)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))
    else:
        # User already is in the guild.
        return None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.ban_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> ban_member(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    delete_message_days: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2065-L2078" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def ban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    delete_message_days: undefined.UndefinedNoneOr[int] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;delete_message_days&#34;, delete_message_days)
    # This endpoint specifies a reason in the body, specifically.
    body.put(&#34;reason&#34;, reason)
    route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, json=body)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.ban_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> ban_user(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    delete_message_days: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2065-L2078" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def ban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    delete_message_days: undefined.UndefinedNoneOr[int] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;delete_message_days&#34;, delete_message_days)
    # This endpoint specifies a reason in the body, specifically.
    body.put(&#34;reason&#34;, reason)
    route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, json=body)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.begin_guild_prune" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> begin_guild_prune(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    compute_prune_count: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    include_roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> Union[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="begin_guild_prune -- Begin the guild prune …" href="../api/rest.html#hikari.api.rest.RESTClient.begin_guild_prune"
class='dotted'>begin_guild_prune</a></code>
</p>
<p>Begin the guild prune.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to begin the guild prune in. This may be a guild object,
or the ID of an existing channel.</dd>
<dt><strong><code>days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, number of days to count prune for.</dd>
<dt><strong><code>compute_prune_count</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to return the prune count. This is discouraged
for large guilds.</dd>
<dt><strong><code>include_roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>If provided, the role(s) to include. By default, this endpoint will
not count users with roles. Providing roles using this attribute
will make members with the specified roles also get included into
the count.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If <code>compute_prune_count</code> is not provided or <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, the
number of members pruned. Else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2217-L2236" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def begin_guild_prune(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    include_roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; typing.Optional[int]:
    route = routes.POST_GUILD_PRUNE.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;days&#34;, days)
    body.put(&#34;compute_prune_count&#34;, compute_prune_count)
    body.put_snowflake_array(&#34;include_roles&#34;, include_roles)
    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    pruned = response.get(&#34;pruned&#34;)
    return int(pruned) if pruned is not None else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.close" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> close() -> None: ...</code></pre>
</dt>
<dd>
<p>Close the HTTP client and any open HTTP connections.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L453-L465" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@typing.final
async def close(self) -&gt; None:
    &#34;&#34;&#34;Close the HTTP client and any open HTTP connections.&#34;&#34;&#34;
    if self._client_session is not None:
        await self._client_session.close()
    await self._connector_factory.close()
    self.global_rate_limit.close()
    self.buckets.close()
    self._closed_event.set()
    # We have to sleep to allow aiohttp time to close SSL transports...
    # https://github.com/aio-libs/aiohttp/issues/1925
    # https://docs.aiohttp.org/en/stable/client_advanced.html#graceful-shutdown
    await asyncio.sleep(0.25)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_crossposts" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_crossposts(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>channels.GuildNewsChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="create_crossposts -- Broadcast an announcement message …" href="../api/rest.html#hikari.api.rest.RESTClient.create_crossposts"
class='dotted'>create_crossposts</a></code>
</p>
<p>Broadcast an announcement message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]</code></dt>
<dd>The object or ID of the news channel to crosspost a message in.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The object or ID of the message to crosspost.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The message object that was crossposted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you tried to crosspost a message that has already been broadcast.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you try to crosspost a message by the current user without the
<code>SEND_MESSAGES</code> permission for the target news channel or try to
crosspost a message by another user without both the <code>SEND_MESSAGES</code>
and <code>MANAGE_MESSAGES</code> permissions for the target channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1058-L1068" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_crossposts(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; messages_.Message:
    route = routes.POST_CHANNEL_CROSSPOST.compile(channel=channel, message=message)

    raw_response = await self._request(route)

    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_dm_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_dm_channel(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="create_dm_channel -- Create a DM channel with a user …" href="../api/rest.html#hikari.api.rest.RESTClient.create_dm_channel"
class='dotted'>create_dm_channel</a></code>
</p>
<p>Create a DM channel with a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to create the DM channel with. This may be a
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a></code></dt>
<dd>The created DM channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1545-L1551" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels.DMChannel:
    route = routes.POST_MY_CHANNELS.compile()
    body = data_binding.JSONObjectBuilder()
    body.put_snowflake(&#34;recipient_id&#34;, user)
    raw_response = await self._request(route, json=body)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_dm(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_emoji(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    image: <a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>,
    *,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1647-L1669" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    image: files.Resourceish,
    *,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; emojis.KnownCustomEmoji:
    route = routes.POST_GUILD_EMOJIS.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    image_resource = files.ensure_resource(image)
    async with image_resource.stream(executor=self._executor) as stream:
        body.put(&#34;image&#34;, await stream.data_uri())

    body.put_snowflake_array(&#34;roles&#34;, roles)

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_guild_category" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_guild_category(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1902-L1921" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_category(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildCategory:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels.ChannelType.GUILD_CATEGORY,
        position=position,
        permission_overwrites=permission_overwrites,
        reason=reason,
    )
    return typing.cast(channels.GuildCategory, channel)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_guild_news_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_guild_news_channel(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1846-L1873" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_news_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildNewsChannel:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels.ChannelType.GUILD_NEWS,
        position=position,
        topic=topic,
        nsfw=nsfw,
        rate_limit_per_user=rate_limit_per_user,
        permission_overwrites=permission_overwrites,
        category=category,
        reason=reason,
    )
    return typing.cast(channels.GuildNewsChannel, channel)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_guild_text_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_guild_text_channel(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1817-L1844" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_text_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildTextChannel:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels.ChannelType.GUILD_TEXT,
        position=position,
        topic=topic,
        nsfw=nsfw,
        rate_limit_per_user=rate_limit_per_user,
        permission_overwrites=permission_overwrites,
        category=category,
        reason=reason,
    )
    return typing.cast(channels.GuildTextChannel, channel)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_guild_voice_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_guild_voice_channel(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    user_limit: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    bitrate: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1875-L1900" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_voice_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildVoiceChannel:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels.ChannelType.GUILD_VOICE,
        position=position,
        user_limit=user_limit,
        bitrate=bitrate,
        permission_overwrites=permission_overwrites,
        category=category,
        reason=reason,
    )
    return typing.cast(channels.GuildVoiceChannel, channel)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_invite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_invite(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    *,
    max_age: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../utilities/date.html#hikari.utilities.date.Intervalish'>date.Intervalish</a>] = UNDEFINED,
    max_uses: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    temporary: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    unique: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    target_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    target_user_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../invites.html#hikari.invites.TargetUserType'>invites.TargetUserType</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="create_invite -- Create an invite to the given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.create_invite"
class='dotted'>create_invite</a></code>
</p>
<p>Create an invite to the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to create a invite for. This may be a channel object,
or the ID of an existing channel.</dd>
<dt><strong><code>max_age</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.timedelta'>datetime.timedelta</a>, <a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the duration of the invite before expiry.</dd>
<dt><strong><code>max_uses</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the max uses the invite can have.</dd>
<dt><strong><code>temporary</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the invite only grants temporary membership.</dd>
<dt><strong><code>unique</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the invite should be unique.</dd>
<dt><strong><code>target_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]]</code></dt>
<dd>If provided, the target user id for this invite. This may be a
user object, or the ID of an existing user.</dd>
<dt><strong><code>target_user_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.TargetUserType'>TargetUserType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the type of target user for this invite.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a></code></dt>
<dd>The invite to the given guild channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNELS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found, or if the target user does not exist,
if specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L867-L889" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_invite(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    *,
    max_age: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
    max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    target_user_type: undefined.UndefinedOr[invites.TargetUserType] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; invites.InviteWithMetadata:
    route = routes.POST_CHANNEL_INVITES.compile(channel=channel)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;max_age&#34;, max_age, conversion=date.timespan_to_int)
    body.put(&#34;max_uses&#34;, max_uses)
    body.put(&#34;temporary&#34;, temporary)
    body.put(&#34;unique&#34;, unique)
    body.put_snowflake(&#34;target_user_id&#34;, target_user)
    body.put(&#34;target_user_type&#34;, target_user_type)
    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_invite_with_metadata(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_message(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    tts: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    nonce: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="create_message -- Create a message in the given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.create_message"
class='dotted'>create_message</a></code>
</p>
<p>Create a message in the given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to create the message in.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If specified, the message contents. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> kwarg is
provided, then this will instead update the embed. This allows for
simpler syntax when sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='../files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If specified, the message embed.</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>],</code></dt>
<dd>If specified, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]],</code></dt>
<dd>If specified, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If specified, whether the message will be TTS (Text To Speech).</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If specified, a nonce that can be used for optimistic message
sending.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If specified, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If specified, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If specified, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If specified, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If specified, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Attachments can be passed as many different things, to aid in
convenience.</p>
<ul>
<li>If a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> to a valid URL, the
resource at the given URL will be streamed to Discord when
sending the message. Subclasses of
<code><a href='../files.html#hikari.files.WebResource'>WebResource</a></code> such as
<code><a href='../files.html#hikari.files.URL'>URL</a></code>,
<code><a href='../messages.html#hikari.messages.Attachment'>Attachment</a></code>,
<code><a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a></code>,
<code>EmbedResource</code>, etc will also be uploaded this way.
This will use bit-inception, so only a small percentage of the
resource will remain in memory at any one time, thus aiding in
scalability.</li>
<li>If a <code><a href='../files.html#hikari.files.Bytes'>Bytes</a></code> is passed, or a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>
that contains a valid data URI is passed, then this is uploaded
with a randomized file name if not provided.</li>
<li>If a <code><a href='../files.html#hikari.files.File'>File</a></code>, <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> that is an absolute or relative path to a file
on your file system is passed, then this resource is uploaded
as an attachment using non-blocking code internally and streamed
using bit-inception where possible. This depends on the
type of <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a></code> that is being used for
the application (default is a thread pool which supports this
behaviour).</li>
</ul>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code>.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; users in <code>user_mentions</code> not being
mentioned in the message content; roles in <code>role_mentions</code> not
being mentioned in the message content.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel or the
person you are trying to message has the DM's disabled.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>You are expected to make a connection to the gateway and identify
once before being able to use this endpoint for a bot.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L975-L1056" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    if not undefined.count(attachment, attachments):
        raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

    if not isinstance(attachments, typing.Collection) and attachments is not undefined.UNDEFINED:
        raise ValueError(
            &#34;You passed a non-collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
            &#34;use &#39;attachment&#39; (singular) instead?&#34;
        )

    route = routes.POST_CHANNEL_MESSAGES.compile(channel=channel)

    if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
        # Syntatic sugar, common mistake to accidentally send an embed
        # as the content, so lets detect this and fix it for the user.
        embed = content
        content = undefined.UNDEFINED

    elif undefined.count(attachment, attachments) == 2 and isinstance(
        content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
    ):
        # Syntatic sugar, common mistake to accidentally send an attachment
        # as the content, so lets detect this and fix it for the user. This
        # will still then work with normal implicit embed attachments as
        # we work this out later.
        attachment = content
        content = undefined.UNDEFINED

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;allowed_mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions))
    body.put(&#34;content&#34;, content, conversion=str)
    body.put(&#34;nonce&#34;, nonce)
    body.put(&#34;tts&#34;, tts)

    final_attachments: typing.List[files.Resource[files.AsyncReader]] = []

    if attachment is not undefined.UNDEFINED:
        final_attachments.append(files.ensure_resource(attachment))
    if attachments is not undefined.UNDEFINED:
        final_attachments.extend([files.ensure_resource(a) for a in attachments])

    if embed is not undefined.UNDEFINED:
        embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
        body.put(&#34;embed&#34;, embed_payload)
        final_attachments.extend(embed_attachments)

    if final_attachments:
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

        stack = contextlib.AsyncExitStack()

        try:
            for i, attachment in enumerate(final_attachments):
                stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=_APPLICATION_OCTET_STREAM)

            raw_response = await self._request(route, form=form)
        finally:
            await stack.aclose()
    else:
        raw_response = await self._request(route, json=body)

    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_role" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_role(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    permissions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    color: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    colour: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    hoist: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentionable: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2123-L2149" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.Role:
    if not undefined.count(color, colour):
        raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

    route = routes.POST_GUILD_ROLES.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;permissions&#34;, permissions)
    body.put(&#34;color&#34;, color)
    body.put(&#34;color&#34;, colour)
    body.put(&#34;hoist&#34;, hoist)
    body.put(&#34;mentionable&#34;, mentionable)

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.create_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> create_webhook(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    avatar: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = None,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="create_webhook -- Create webhook in a channel …" href="../api/rest.html#hikari.api.rest.RESTClient.create_webhook"
class='dotted'>create_webhook</a></code>
</p>
<p>Create webhook in a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the webhook will be created. This may be
a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an existing
channel.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The name for the webhook. This cannnot be <code>clyde</code>.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If specified, the avatar for the webhook.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code></dt>
<dd>The created webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/reference/introduction.html#grammar-token-name'>name</a></code> doesnt follow the restrictions enforced by discord.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1259-L1278" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_webhook(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    name: str,
    *,
    avatar: typing.Optional[files.Resourceish] = None,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.Webhook:
    route = routes.POST_CHANNEL_WEBHOOKS.compile(channel=channel)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)

    if avatar is not None:
        avatar_resource = files.ensure_resource(avatar)
        async with avatar_resource.stream(executor=self._executor) as stream:
            body.put(&#34;avatar&#34;, await stream.data_uri())

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_webhook(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_all_reactions" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_all_reactions(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_all_reactions -- Delete all reactions from a message …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_all_reactions"
class='dotted'>delete_all_reactions</a></code>
</p>
<p>Delete all reactions from a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete all reactions from is.
This may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an
existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to delete all reaction from. This may be a
<code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or the ID of an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1237-L1243" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_all_reactions(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; None:
    route = routes.DELETE_ALL_REACTIONS.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_all_reactions_for_emoji(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_all_reactions_for_emoji -- Delete all reactions for a single emoji on a given message …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_all_reactions_for_emoji"
class='dotted'>delete_all_reactions_for_emoji</a></code>
</p>
<p>Delete all reactions for a single emoji on a given message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete the reactions from is.
This may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an
existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to delete a reactions from. This may be a
<code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to delete all reactions from.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1209-L1220" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_all_reactions_for_emoji(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
    emoji: emojis.Emojiish,
) -&gt; None:
    route = routes.DELETE_REACTION_EMOJI.compile(
        emoji=self._transform_emoji_to_url_format(emoji),
        channel=channel,
        message=message,
    )
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_channel(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_channel -- Delete a channel in a guild, or close a DM …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_channel"
class='dotted'>delete_channel</a></code>
</p>
<p>Delete a channel in a guild, or close a DM.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>The channel to delete. This may be a channel object, or the ID of an
existing channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>For Public servers, the set 'Rules' or 'Guidelines' channels and the
'Public Server Updates' channel cannot be deleted.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L813-L815" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_channel(self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]) -&gt; None:
    route = routes.DELETE_CHANNEL.compile(channel=channel)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_emoji(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1693-L1701" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
    # likewise this only is valid for custom emojis, unicode emojis make little sense here.
    emoji: typing.Union[str, emojis.CustomEmoji],
) -&gt; None:
    route = routes.DELETE_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_guild(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_guild -- Delete a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_guild"
class='dotted'>delete_guild</a></code>
</p>
<p>Delete a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete. This may be a <code><a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a></code> or
the ID of an existing guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not the owner of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If you own the guild or if you are not in it.</dd>
</dl>
<p>hikari.errors.InternalServerError
If an internal error occurs on Discord while handling the request.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1803-L1805" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
    route = routes.DELETE_GUILD.compile(guild=guild)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_integration" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_integration(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    integration: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.Integration'>guilds.Integration</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2283-L2291" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_integration(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    integration: snowflakes.SnowflakeishOr[guilds.Integration],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_INTEGRATION.compile(guild=guild, integration=integration)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_invite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_invite(
    invite: <a href='../invites.html#hikari.invites.Inviteish'>invites.Inviteish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_invite -- Delete an existing invite …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_invite"
class='dotted'>delete_invite</a></code>
</p>
<p>Delete an existing invite.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.Inviteish'>Inviteish</a></code></dt>
<dd>The invite to delete. This may be a <code><a href='../invites.html#hikari.invites.Invite'>Invite</a></code> or
the code of an existing invite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission in the guild
the invite is from or if you are missing the <code>MANAGE_CHANNELS</code>
permission in the channel the invite is from.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the invite is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1484-L1486" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_invite(self, invite: invites.Inviteish) -&gt; None:
    route = routes.DELETE_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_message(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_message -- Delete a given message in a given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_message"
class='dotted'>delete_message</a></code>
</p>
<p>Delete a given message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to delete the message in. This may be
a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an existing
channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to delete. This may be a <code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or
the ID of an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code>, and the message is
not sent by you.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1115-L1121" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; None:
    route = routes.DELETE_CHANNEL_MESSAGE.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_messages" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_messages(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    /,
    *messages: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_messages -- Bulk-delete messages from the channel …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_messages"
class='dotted'>delete_messages</a></code>
</p>
<p>Bulk-delete messages from the channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to bulk delete the messages in. This may be
a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an existing
channel.</dd>
<dt><strong><code>*messages</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The messages to delete. This may be one or more
<code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or the ID of existing messages.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This API endpoint will only be able to delete 100 messages
at a time. For anything more than this, multiple requests will
be executed one-after-the-other, since the rate limits for this
endpoint do not favour more than one request per bucket.</p>
<p>If one message is left over from chunking per 100 messages, or
only one message is passed to this coroutine function, then the
logic is expected to defer to <code>delete_message</code>. The implication
of this is that the <code>delete_message</code> endpoint is ratelimited
by a different bucket with different usage rates.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This endpoint is not atomic. If an error occurs midway through
a bulk delete, you will <strong>not</strong> be able to revert any changes made
up to this point.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Specifying any messages more than 14 days old will cause the call
to fail, potentially with partial completion.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BulkDeleteError'>BulkDeleteError</a></code></dt>
<dd>An error containing the messages successfully deleted, and the
messages that were not removed. The
<code>BaseException.__cause__</code> of the exception will be the
original error that terminated this process.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1123-L1161" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_messages(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    /,
    *messages: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; None:
    route = routes.POST_DELETE_CHANNEL_MESSAGES_BULK.compile(channel=channel)

    pending: typing.Deque[snowflakes.SnowflakeishOr[messages_.Message]] = collections.deque(messages)
    deleted: typing.Deque[snowflakes.SnowflakeishOr[messages_.Message]] = collections.deque()

    while pending:
        # Discord only allows 2-100 messages in the BULK_DELETE endpoint. Because of that,
        # if the user wants 101 messages deleted, we will post 100 messages in bulk delete
        # and then the last message in a normal delete.
        # Along with this, the bucket size for v6 and v7 seems to be a bit restrictive. As of
        # 30th July 2020, this endpoint returned the following headers when being ratelimited:
        #       x-ratelimit-bucket         b05c0d8c2ab83895085006a8eae073a3
        #       x-ratelimit-limit          1
        #       x-ratelimit-remaining      0
        #       x-ratelimit-reset          1596033974.096
        #       x-ratelimit-reset-after    3.000
        # This kind of defeats the point of asynchronously gathering any of these
        # in the first place really. To save clogging up the event loop
        # (albeit at a cost of maybe a couple-dozen milliseconds per call),
        # I am just gonna invoke these sequentially instead.
        try:
            if len(pending) == 1:
                message = pending.popleft()
                await self.delete_message(channel, message)
                deleted.append(message)
            else:
                body = data_binding.JSONObjectBuilder()
                chunk = [pending.popleft() for _ in range(min(100, len(pending)))]
                body.put_snowflake_array(&#34;messages&#34;, chunk)
                await self._request(route, json=body)
                deleted += chunk
        except Exception as ex:
            raise errors.BulkDeleteError(deleted, pending) from ex</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_my_reaction" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_my_reaction(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_my_reaction -- Delete a reaction that your application user created …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_my_reaction"
class='dotted'>delete_my_reaction</a></code>
</p>
<p>Delete a reaction that your application user created.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete the reaction from is.
This may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an
existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to delete a reaction from. This may be a
<code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to remove your reaction from.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1196-L1207" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_my_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
    emoji: emojis.Emojiish,
) -&gt; None:
    route = routes.DELETE_MY_REACTION.compile(
        emoji=self._transform_emoji_to_url_format(emoji),
        channel=channel,
        message=message,
    )
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_permission_overwrite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_permission_overwrite(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    target: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>, <a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>]],
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_permission_overwrite -- Delete a custom permission for an entity in a given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_permission_overwrite"
class='dotted'>delete_permission_overwrite</a></code>
</p>
<p>Delete a custom permission for an entity in a given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to delete a permission overwrite in. This may be a
channel object, or the ID of an existing channel.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>]</code></dt>
<dd>The channel overwrite to delete.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the target is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L849-L857" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_permission_overwrite(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    target: snowflakes.SnowflakeishOr[
        typing.Union[channels.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
    ],
) -&gt; None:
    route = routes.DELETE_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_reaction" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_reaction(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_reaction -- Delete a reaction from a message …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_reaction"
class='dotted'>delete_reaction</a></code>
</p>
<p>Delete a reaction from a message.</p>
<p>If you are looking to delete your own applications reaction, use
<code>delete_my_reaction</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete the reaction from is.
This may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an
existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to delete a reaction from. This may be a
<code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to delete all reactions from.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1222-L1235" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
    emoji: emojis.Emojiish,
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; None:
    route = routes.DELETE_REACTION_USER.compile(
        emoji=self._transform_emoji_to_url_format(emoji),
        channel=channel,
        message=message,
        user=user,
    )
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_role" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_role(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2190-L2196" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
) -&gt; None:
    route = routes.DELETE_GUILD_ROLE.compile(guild=guild, role=role)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.delete_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> delete_webhook(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="delete_webhook -- Delete a webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_webhook"
class='dotted'>delete_webhook</a></code>
</p>
<p>Delete a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to delete. This may be a <code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code>
or the ID of an existing webhook.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If specified, the webhoook token that will be used to delete
the webhook instead of the token the client was initialized with.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhoook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1347-L1360" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    if token is undefined.UNDEFINED:
        route = routes.DELETE_WEBHOOK.compile(webhook=webhook)
        no_auth = False
    else:
        route = routes.DELETE_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
        no_auth = True

    await self._request(route, no_auth=no_auth)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_channel(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    /,
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    bitrate: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    user_limit: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../utilities/date.html#hikari.utilities.date.Intervalish'>date.Intervalish</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    parent_category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="edit_channel -- Edit a channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_channel"
class='dotted'>edit_channel</a></code>
</p>
<p>Edit a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to edit. This may be a channel object, or the ID of an
existing channel.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>hikari.undefined.UndefinedOr[[builtins.str]</code></dt>
<dd>If provided, the new name for the channel.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>hikari.undefined.UndefinedOr[[builtins.int]</code></dt>
<dd>If provided, the new position for the channel.</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new topic for the channel.</dd>
<dt><strong><code>nsfw</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the channel should be marked as NSFW or not.</dd>
<dt><strong><code>bitrate</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the new bitrate for the channel.</dd>
<dt><strong><code>user_limit</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the new user limit in the channel.</dd>
<dt><strong><code>rate_limit_per_user</code></strong> :&ensp;<code><a href='../utilities/date.html#hikari.utilities.date.Intervalish'>Intervalish</a></code></dt>
<dd>If provided, the new rate limit per user in the channel.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the new permission overwrites for the channel.</dd>
<dt><strong><code>parent_category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>If provided, the new guild category for the channel.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code></dt>
<dd>The edited channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing permissions to edit the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L759-L795" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_channel(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    /,
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    parent_category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.PartialChannel:
    route = routes.PATCH_CHANNEL.compile(channel=channel)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;position&#34;, position)
    body.put(&#34;topic&#34;, topic)
    body.put(&#34;nsfw&#34;, nsfw)
    body.put(&#34;bitrate&#34;, bitrate)
    body.put(&#34;user_limit&#34;, user_limit)
    body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user)
    body.put_snowflake(&#34;parent_id&#34;, parent_category)
    body.put_array(
        &#34;permission_overwrites&#34;,
        permission_overwrites,
        conversion=self._entity_factory.serialize_permission_overwrite,
    )

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_channel(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_emoji(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1671-L1691" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
    # likewise this only is valid for custom emojis, unicode emojis make little sense here.
    emoji: typing.Union[str, emojis.CustomEmoji],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; emojis.KnownCustomEmoji:
    route = routes.PATCH_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put_snowflake_array(&#34;roles&#34;, roles)

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_guild(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    region: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../voices.html#hikari.voices.VoiceRegionish'>voices.VoiceRegionish</a>] = UNDEFINED,
    verification_level: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildVerificationLevel'>guilds.GuildVerificationLevel</a>] = UNDEFINED,
    default_message_notifications: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildMessageNotificationsLevel'>guilds.GuildMessageNotificationsLevel</a>] = UNDEFINED,
    explicit_content_filter_level: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildExplicitContentFilterLevel'>guilds.GuildExplicitContentFilterLevel</a>] = UNDEFINED,
    afk_channel: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels.GuildVoiceChannel</a>]] = UNDEFINED,
    afk_timeout: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../utilities/date.html#hikari.utilities.date.Intervalish'>date.Intervalish</a>] = UNDEFINED,
    icon: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    owner: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    splash: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    banner: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    system_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels.GuildTextChannel</a>]] = UNDEFINED,
    rules_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels.GuildTextChannel</a>]] = UNDEFINED,
    public_updates_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels.GuildTextChannel</a>]] = UNDEFINED,
    preferred_locale: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.RESTGuild'>guilds.RESTGuild</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1722-L1801" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_guild(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    region: undefined.UndefinedOr[voices.VoiceRegionish] = undefined.UNDEFINED,
    verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
    default_message_notifications: undefined.UndefinedOr[
        guilds.GuildMessageNotificationsLevel
    ] = undefined.UNDEFINED,
    explicit_content_filter_level: undefined.UndefinedOr[
        guilds.GuildExplicitContentFilterLevel
    ] = undefined.UNDEFINED,
    afk_channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]] = undefined.UNDEFINED,
    afk_timeout: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
    icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    system_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildTextChannel]
    ] = undefined.UNDEFINED,
    rules_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildTextChannel]
    ] = undefined.UNDEFINED,
    public_updates_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildTextChannel]
    ] = undefined.UNDEFINED,
    preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.RESTGuild:
    route = routes.PATCH_GUILD.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;region&#34;, region, conversion=str)
    body.put(&#34;verification&#34;, verification_level)
    body.put(&#34;notifications&#34;, default_message_notifications)
    body.put(&#34;explicit_content_filter&#34;, explicit_content_filter_level)
    body.put(&#34;afk_timeout&#34;, afk_timeout)
    body.put(&#34;preferred_locale&#34;, preferred_locale, conversion=str)
    body.put_snowflake(&#34;afk_channel_id&#34;, afk_channel)
    body.put_snowflake(&#34;owner_id&#34;, owner)
    body.put_snowflake(&#34;system_channel_id&#34;, system_channel)
    body.put_snowflake(&#34;rules_channel_id&#34;, rules_channel)
    body.put_snowflake(&#34;public_updates_channel_id&#34;, public_updates_channel)

    tasks: typing.List[asyncio.Task[str]] = []

    if icon is None:
        body.put(&#34;icon&#34;, None)
    elif icon is not undefined.UNDEFINED:
        icon_resource = files.ensure_resource(icon)
        async with icon_resource.stream(executor=self._executor) as stream:
            task = asyncio.create_task(stream.data_uri())
            task.add_done_callback(lambda future: body.put(&#34;icon&#34;, future.result()))
            tasks.append(task)

    if splash is None:
        body.put(&#34;splash&#34;, None)
    elif splash is not undefined.UNDEFINED:
        splash_resource = files.ensure_resource(splash)
        async with splash_resource.stream(executor=self._executor) as stream:
            task = asyncio.create_task(stream.data_uri())
            task.add_done_callback(lambda future: body.put(&#34;splash&#34;, future.result()))
            tasks.append(task)

    if banner is None:
        body.put(&#34;banner&#34;, None)
    elif banner is not undefined.UNDEFINED:
        banner_resource = files.ensure_resource(banner)
        async with banner_resource.stream(executor=self._executor) as stream:
            task = asyncio.create_task(stream.data_uri())
            task.add_done_callback(lambda future: body.put(&#34;banner&#34;, future.result()))
            tasks.append(task)

    await asyncio.gather(*tasks)

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_rest_guild(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_integration" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_integration(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    integration: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.Integration'>guilds.Integration</a>],
    *,
    expire_behaviour: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.IntegrationExpireBehaviour'>guilds.IntegrationExpireBehaviour</a>] = UNDEFINED,
    expire_grace_period: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../utilities/date.html#hikari.utilities.date.Intervalish'>date.Intervalish</a>] = UNDEFINED,
    enable_emojis: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2265-L2281" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_integration(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    integration: snowflakes.SnowflakeishOr[guilds.Integration],
    *,
    expire_behaviour: undefined.UndefinedOr[guilds.IntegrationExpireBehaviour] = undefined.UNDEFINED,
    expire_grace_period: undefined.UndefinedOr[date.Intervalish] = undefined.UNDEFINED,
    enable_emojis: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PATCH_GUILD_INTEGRATION.compile(guild=guild, integration=integration)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;expire_behaviour&#34;, expire_behaviour)
    body.put(&#34;expire_grace_period&#34;, expire_grace_period, conversion=date.timespan_to_int)
    # Inconsistent naming in the API itself, so I have changed the name.
    body.put(&#34;enable_emoticons&#34;, enable_emojis)
    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_member(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    nick: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    mute: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    deaf: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    voice_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels.GuildVoiceChannel</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1989-L2017" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    voice_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PATCH_GUILD_MEMBER.compile(guild=guild, user=user)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;nick&#34;, nick)
    body.put(&#34;mute&#34;, mute)
    body.put(&#34;deaf&#34;, deaf)
    body.put_snowflake_array(&#34;roles&#34;, roles)

    if voice_channel is None:
        body.put(&#34;channel_id&#34;, None)
    elif voice_channel is not undefined.UNDEFINED:
        body.put_snowflake(&#34;channel_id&#34;, voice_channel)

    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_message(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    flags: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../messages.html#hikari.messages.MessageFlag'>messages_.MessageFlag</a>] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="edit_message -- Edit an existing message in a given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_message"
class='dotted'>edit_message</a></code>
</p>
<p>Edit an existing message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to create the message in. This may be
a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an existing
channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to edit. This may be a <code><a href='../messages.html#hikari.messages.Message'>Message</a></code>
or the ID of an existing message.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>The message content to update with. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the content will not
be changed. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the content will be removed.</p>
<p>Any other value will be cast to a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> before sending.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> kwarg is
provided, then this will instead update the embed. This allows for
simpler syntax when sending an embed alone.</p>
</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>The embed to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed if
present is not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the embed
is removed if present. Otherwise, the new embed value that was
provided will be used as the replacement.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>Sanitation for <code>@everyone</code> mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then <code>@everyone</code>/<code>@here</code> mentions
in the message content will show up as mentioning everyone that can
view the chat.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>
<p>Sanitation for user mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all valid user mentions will behave
as mentions. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all valid user mentions will not
behave as mentions.</p>
<p>You may alternatively pass a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code> user IDs, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code>-derived objects.</p>
</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>
<p>Sanitation for role mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all valid role mentions will behave
as mentions. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all valid role mentions will not
behave as mentions.</p>
<p>You may alternatively pass a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code> role IDs, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code>-derived objects.</p>
</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../messages.html#hikari.messages.MessageFlag'>MessageFlag</a>]</code></dt>
<dd>
<p>Optional flags to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing is changed.</p>
<p>Note that some flags may not be able to be set. Currently the only
flags that can be set are <code>NONE</code> and <code>SUPPRESS_EMBEDS</code>. If you
have <code>MANAGE_MESSAGES</code> permissions, you can use this call to
suppress embeds on another user's message.</p>
</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Mentioning everyone, roles, or users in message edits currently
will not send a push notification showing a new mention to people
on Discord. It will still highlight in their chat as if they
were mentioned, however.</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>There is currently no documented way to clear attachments or edit
attachments from a previously sent message on Discord's API. To
do this, <code>delete</code> the message and re-send it. This also applies
to embed attachments.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify one of <code>mentions_everyone</code>, <code>user_mentions</code>, or
<code>role_mentions</code>, then all others will default to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>,
even if they were enabled previously.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all three of
them each time.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If the message was not sent by your user, the only parameter
you may provide to this call is the <code>flags</code> parameter. Anything
else will result in a <code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code> being raised.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The edited message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no embeds; messages with more than 2000 characters
in them, embeds that exceed one of the many embed
limits; invalid image URLs in embeds; users in <code>user_mentions</code> not
being mentioned in the message content; roles in <code>role_mentions</code> not
being mentioned in the message content.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel; if you try to
change the contents of another user's message; or if you try to edit
the flags on another user's message without the <code>MANAGE_MESSAGES</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1070-L1113" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
    ] = undefined.UNDEFINED,
    flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    route = routes.PATCH_CHANNEL_MESSAGE.compile(channel=channel, message=message)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;flags&#34;, flags)
    if undefined.count(mentions_everyone, user_mentions, role_mentions) != 3:
        body.put(
            &#34;allowed_mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions)
        )

    if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
        # Syntatic sugar, common mistake to accidentally send an embed
        # as the content, so lets detect this and fix it for the user.
        embed = content
        content = undefined.UNDEFINED

    if content is not None:
        body.put(&#34;content&#34;, content, conversion=str)
    else:
        body.put(&#34;content&#34;, None)

    if isinstance(embed, embeds_.Embed):
        embed_payload, _ = self._entity_factory.serialize_embed(embed)
        body.put(&#34;embed&#34;, embed_payload)
    elif embed is None:
        body.put(&#34;embed&#34;, None)

    raw_response = await self._request(route, json=body)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_my_nick" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_my_nick(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.Guild'>guilds.Guild</a>],
    nick: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2019-L2029" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_my_nick(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.Guild],
    nick: typing.Optional[str],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PATCH_MY_GUILD_NICKNAME.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;nick&#34;, nick)
    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_my_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_my_user(
    *,
    username: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
) -> <a href='../users.html#hikari.users.OwnUser'>OwnUser</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="edit_my_user -- Edit the token's associated user …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_my_user"
class='dotted'>edit_my_user</a></code>
</p>
<p>Edit the token's associated user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If specified, the new username.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If specified, the new avatar. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
the avatar will be removed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The edited token's associated user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1494-L1513" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_my_user(
    self,
    *,
    username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
) -&gt; users.OwnUser:
    route = routes.PATCH_MY_USER.compile()
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;username&#34;, username)

    if avatar is None:
        body.put(&#34;avatar&#34;, None)
    elif avatar is not undefined.UNDEFINED:
        avatar_resource = files.ensure_resource(avatar)
        async with avatar_resource.stream(executor=self._executor) as stream:
            body.put(&#34;avatar&#34;, await stream.data_uri())

    raw_response = await self._request(route, json=body)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_my_user(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_permission_overwrites" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_permission_overwrites(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    target: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>, <a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>],
    *,
    target_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.PermissionOverwriteType'>channels.PermissionOverwriteType</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]] = UNDEFINED,
    allow: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    deny: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="edit_permission_overwrites -- Edit permissions for a specific entity in the given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_permission_overwrites"
class='dotted'>edit_permission_overwrites</a></code>
</p>
<p>Edit permissions for a specific entity in the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to edit a permission overwrite in. This may be a
channel object, or the ID of an existing channel.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>]</code></dt>
<dd>The channel overwrite to edit. This may be a overwrite object, or the ID of an
existing channel.</dd>
<dt><strong><code>target_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.PermissionOverwriteType'>PermissionOverwriteType</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]</code></dt>
<dd>If provided, the type of the target to update. If unset, will attempt to get
the type from <code><a href='https://docs.python.org/3/reference/simple_stmts.html#grammar-token-target'>target</a></code>.</dd>
<dt><strong><code>allow</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new vale of all allowed permissions.</dd>
<dt><strong><code>deny</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new vale of all disallowed permissions.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>target_type</code> is unset and we were unable to determine the type
from <code><a href='https://docs.python.org/3/reference/simple_stmts.html#grammar-token-target'>target</a></code>.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the target is not found if it is
a role.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L817-L847" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_permission_overwrites(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    target: typing.Union[
        snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels.PermissionOverwrite
    ],
    *,
    target_type: undefined.UndefinedOr[typing.Union[channels.PermissionOverwriteType, str]] = undefined.UNDEFINED,
    allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    if target_type is undefined.UNDEFINED:
        if isinstance(target, users.PartialUser):
            target_type = channels.PermissionOverwriteType.MEMBER
        elif isinstance(target, guilds.Role):
            target_type = channels.PermissionOverwriteType.ROLE
        elif isinstance(target, channels.PermissionOverwrite):
            target_type = target.type
        else:
            raise TypeError(
                &#34;Cannot determine the type of the target to update. Try specifying &#39;target_type&#39; manually.&#34;
            )

    route = routes.PATCH_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;type&#34;, target_type)
    body.put(&#34;allow&#34;, allow)
    body.put(&#34;deny&#34;, deny)

    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_role" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_role(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    permissions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    color: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    colour: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    hoist: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentionable: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2160-L2188" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.Role:
    if not undefined.count(color, colour):
        raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

    route = routes.PATCH_GUILD_ROLE.compile(guild=guild, role=role)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;permissions&#34;, permissions)
    body.put(&#34;color&#34;, color)
    body.put(&#34;color&#34;, colour)
    body.put(&#34;hoist&#34;, hoist)
    body.put(&#34;mentionable&#34;, mentionable)

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_webhook(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    channel: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="edit_webhook -- Edit a webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_webhook"
class='dotted'>edit_webhook</a></code>
</p>
<p>Edit a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to edit. This may be a <code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code>
or the ID of an existing webhook.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If specified, the webhoook token that will be used to edit
the webhook instead of the token the client was initialized with.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If specified, the new webhook name.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If specified, the new webhook avatar. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, will
remove the webhook avatar.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]]</code></dt>
<dd>If specified, the text channel to move the webhook to.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code></dt>
<dd>The edited webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1315-L1345" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.TextChannel]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.Webhook:
    if token is undefined.UNDEFINED:
        route = routes.PATCH_WEBHOOK.compile(webhook=webhook)
        no_auth = False
    else:
        route = routes.PATCH_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
        no_auth = True

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put_snowflake(&#34;channel&#34;, channel)

    if avatar is None:
        body.put(&#34;avatar&#34;, None)
    elif avatar is not undefined.UNDEFINED:
        avatar_resource = files.ensure_resource(avatar)
        async with avatar_resource.stream(executor=self._executor) as stream:
            body.put(&#34;avatar&#34;, await stream.data_uri())

    raw_response = await self._request(route, json=body, reason=reason, no_auth=no_auth)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_webhook(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.edit_widget" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> edit_widget(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>]] = UNDEFINED,
    enabled: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2307-L2326" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_widget(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels.GuildChannel]] = undefined.UNDEFINED,
    enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.GuildWidget:
    route = routes.PATCH_GUILD_WIDGET.compile(guild=guild)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;enabled&#34;, enabled)
    if channel is None:
        body.put(&#34;channel&#34;, None)
    elif channel is not undefined.UNDEFINED:
        body.put_snowflake(&#34;channel&#34;, channel)

    raw_response = await self._request(route, json=body, reason=reason)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_guild_widget(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> estimate_guild_prune_count(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    include_roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="estimate_guild_prune_count -- Estimate the guild prune count …" href="../api/rest.html#hikari.api.rest.RESTClient.estimate_guild_prune_count"
class='dotted'>estimate_guild_prune_count</a></code>
</p>
<p>Estimate the guild prune count.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to estimate the guild prune count for. This may be a guild object,
or the ID of an existing channel.</dd>
<dt><strong><code>days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, number of days to count prune for.</dd>
<dt><strong><code>include_roles</code></strong> :&ensp;<code>hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole][</code></dt>
<dd>If provided, the role(s) to include. By default, this endpoint will
not count users with roles. Providing roles using this attribute
will make members with the specified roles also get included into
the count.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The estimated guild prune count.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2198-L2215" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def estimate_guild_prune_count(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    include_roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
) -&gt; int:
    route = routes.GET_GUILD_PRUNE.compile(guild=guild)
    query = data_binding.StringMapBuilder()
    query.put(&#34;days&#34;, days)
    if include_roles is not undefined.UNDEFINED:
        roles = &#34;,&#34;.join(str(int(role)) for role in include_roles)
        query.put(&#34;include_roles&#34;, roles)
    raw_response = await self._request(route, query=query)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return int(response[&#34;pruned&#34;])</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.execute_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> execute_webhook(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    username: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar_url: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    tts: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="execute_webhook -- Execute a webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.execute_webhook"
class='dotted'>execute_webhook</a></code>
</p>
<p>Execute a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to execute. This may be a <code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code>
or the ID of an existing webhook</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The webhook token.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If specified, the message contents. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> nor
no <code>embeds</code> kwarg is provided, then this will instead
update the embed. This allows for simpler syntax when
sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='../files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If specified, the message embed.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If specified, the message embeds.</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>],</code></dt>
<dd>If specified, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]],</code></dt>
<dd>If specified, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If specified, whether the message will be TTS (Text To Speech).</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If specified, a nonce that can be used for optimistic message
sending.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If specified, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If specified, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If specified, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If specified, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If specified, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Attachments can be passed as many different things, to aid in
convenience.</p>
<ul>
<li>If a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> to a valid URL, the
resource at the given URL will be streamed to Discord when
sending the message. Subclasses of
<code><a href='../files.html#hikari.files.WebResource'>WebResource</a></code> such as
<code><a href='../files.html#hikari.files.URL'>URL</a></code>,
<code><a href='../messages.html#hikari.messages.Attachment'>Attachment</a></code>,
<code><a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a></code>,
<code>EmbedResource</code>, etc will also be uploaded this way.
This will use bit-inception, so only a small percentage of the
resource will remain in memory at any one time, thus aiding in
scalability.</li>
<li>If a <code><a href='../files.html#hikari.files.Bytes'>Bytes</a></code> is passed, or a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>
that contains a valid data URI is passed, then this is uploaded
with a randomized file name if not provided.</li>
<li>If a <code><a href='../files.html#hikari.files.File'>File</a></code>, <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> that is an absolute or relative path to a file
on your file system is passed, then this resource is uploaded
as an attachment using non-blocking code internally and streamed
using bit-inception where possible. This depends on the
type of <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a></code> that is being used for
the application (default is a thread pool which supports this
behaviour).</li>
</ul>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code>.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified or if both
<code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; users in <code>user_mentions</code> not being
mentioned in the message content; roles in <code>role_mentions</code> not
being mentioned in the message content.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1362-L1461" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def execute_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    token: str,
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    if not undefined.count(attachment, attachments):
        raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

    if not undefined.count(embed, embeds):
        raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

    if not isinstance(embeds, typing.Collection) and embeds is not undefined.UNDEFINED:
        raise TypeError(
            &#34;You passed a non collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
            &#34;use &#39;embed&#39; (singular) instead?&#34;
        )

    if not isinstance(attachments, typing.Collection) and attachments is not undefined.UNDEFINED:
        raise TypeError(
            &#34;You passed a non collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
            &#34;use &#39;attachment&#39; (singular) instead?&#34;
        )

    if undefined.count(embed, embeds) == 2 and isinstance(content, embeds_.Embed):
        # Syntatic sugar, common mistake to accidentally send an embed
        # as the content, so lets detect this and fix it for the user.
        embed = content
        content = undefined.UNDEFINED

    elif undefined.count(attachment, attachments) == 2 and isinstance(
        content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
    ):
        # Syntatic sugar, common mistake to accidentally send an attachment
        # as the content, so lets detect this and fix it for the user. This
        # will still then work with normal implicit embed attachments as
        # we work this out later.
        attachment = content
        content = undefined.UNDEFINED

    route = routes.POST_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)

    final_attachments: typing.List[files.Resource[files.AsyncReader]] = []
    if attachment is not undefined.UNDEFINED:
        final_attachments.append(files.ensure_resource(attachment))
    if attachments is not undefined.UNDEFINED:
        final_attachments.extend([files.ensure_resource(a) for a in attachments])

    serialized_embeds: data_binding.JSONArray = []

    if embeds is not undefined.UNDEFINED:
        for embed in embeds:
            embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
            serialized_embeds.append(embed_payload)
            final_attachments.extend(embed_attachments)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;mentions&#34;, self._generate_allowed_mentions(mentions_everyone, user_mentions, role_mentions))
    body.put(&#34;content&#34;, content, conversion=str)
    body.put(&#34;embeds&#34;, serialized_embeds)
    body.put(&#34;username&#34;, username)
    body.put(&#34;avatar_url&#34;, avatar_url)
    body.put(&#34;tts&#34;, tts)
    query = data_binding.StringMapBuilder()
    query.put(&#34;wait&#34;, True)

    if final_attachments:
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

        stack = contextlib.AsyncExitStack()

        try:
            for i, attachment in enumerate(final_attachments):
                stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=_APPLICATION_OCTET_STREAM)

            raw_response = await self._request(route, query=query, form=form, no_auth=True)
        finally:
            await stack.aclose()
    else:
        raw_response = await self._request(route, query=query, json=body, no_auth=True)

    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_application" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_application() -> <a href='../applications.html#hikari.applications.Application'>applications.Application</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_application -- Fetch the token's associated application …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_application"
class='dotted'>fetch_application</a></code>
</p>
<p>Fetch the token's associated application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.Application'>Application</a></code></dt>
<dd>The token's associated application.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1553-L1557" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_application(self) -&gt; applications.Application:
    route = routes.GET_MY_APPLICATION.compile()
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_application(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_audit_log" class="hljs python"><abbr title='A standard Python function.'>def</abbr> fetch_audit_log(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    before: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    event_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLogEventType'>audit_logs.AuditLogEventType</a>] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLog'>audit_logs.AuditLog</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1599-L1623" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_audit_log(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    event_type: undefined.UndefinedOr[audit_logs.AuditLogEventType] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:

    timestamp: undefined.UndefinedOr[str]
    if before is undefined.UNDEFINED:
        timestamp = undefined.UNDEFINED
    elif isinstance(before, datetime.datetime):
        timestamp = str(snowflakes.Snowflake.from_datetime(before))
    else:
        timestamp = str(int(before))

    return special_endpoints.AuditLogIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        guild=guild,
        before=timestamp,
        user=user,
        action_type=event_type,
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_ban" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_ban(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildMemberBan'>GuildMemberBan</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2094-L2102" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_ban(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; guilds.GuildMemberBan:
    route = routes.GET_GUILD_BAN.compile(guild=guild, user=user)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_guild_member_ban(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_bans" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_bans(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../guilds.html#hikari.guilds.GuildMemberBan'>GuildMemberBan</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2104-L2110" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_bans(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[guilds.GuildMemberBan]:
    route = routes.GET_GUILD_BANS.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_guild_member_ban)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_channel(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
) -> <a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_channel -- Fetch a channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_channel"
class='dotted'>fetch_channel</a></code>
</p>
<p>Fetch a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a></code></dt>
<dd>The channel to fetch. This may be a
<code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code> object, or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code></dt>
<dd>
<p>The channel. This will be a <em>derivative</em> of
<code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code>, depending on the type of
channel you request for.</p>
<p>This means that you may get one of
<code><a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GroupDMChannel'>GroupDMChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildStoreChannel'>GuildStoreChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a></code>.</p>
<p>Likewise, the <code><a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a></code> can be used to
determine if a channel is guild-bound, and
<code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> can be used to determine
if the channel provides textual functionality to the application.</p>
<p>You can check for these using the <code><a href='https://docs.python.org/3/library/functions.html#isinstance'>isinstance</a></code>
builtin function.</p>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L751-L757" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel(
    self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]
) -&gt; channels.PartialChannel:
    route = routes.GET_CHANNEL.compile(channel=channel)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_channel(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_channel_invites" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_channel_invites(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_channel_invites -- Fetch all invites pointing to the given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_channel_invites"
class='dotted'>fetch_channel_invites</a></code>
</p>
<p>Fetch all invites pointing to the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to fetch the invites from. This may be a channel
object, or the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The invites pointing to the given guild channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found in any guilds you are a member of.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L859-L865" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel_invites(
    self, channel: snowflakes.SnowflakeishOr[channels.GuildChannel]
) -&gt; typing.Sequence[invites.InviteWithMetadata]:
    route = routes.GET_CHANNEL_INVITES.compile(channel=channel)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_invite_with_metadata)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_channel_webhooks(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_channel_webhooks -- Fetch all channel webhooks …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_channel_webhooks"
class='dotted'>fetch_channel_webhooks</a></code>
</p>
<p>Fetch all channel webhooks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch the webhooks for. This
may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The fetched webhooks.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1297-L1304" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel_webhooks(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
) -&gt; typing.Sequence[webhooks.Webhook]:
    route = routes.GET_CHANNEL_WEBHOOKS.compile(channel=channel)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_webhook)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_emoji(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1625-L1635" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    # This is an emoji ID, which is the URL-safe emoji name, not the snowflake alone.
    # likewise this only is valid for custom emojis, unicode emojis make little sense here.
    emoji: typing.Union[str, emojis.CustomEmoji],
) -&gt; emojis.KnownCustomEmoji:
    route = routes.GET_GUILD_EMOJI.compile(guild=guild, emoji=self._transform_emoji_to_url_format(emoji))
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_gateway_bot" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_gateway_bot() -> <a href='../sessions.html#hikari.sessions.GatewayBot'>sessions.GatewayBot</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_gateway_bot -- Fetch the gateway gateway info for the bot …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_gateway_bot"
class='dotted'>fetch_gateway_bot</a></code>
</p>
<p>Fetch the gateway gateway info for the bot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../sessions.html#hikari.sessions.GatewayBot'>GatewayBot</a></code></dt>
<dd>The gateway bot.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1470-L1474" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_gateway_bot(self) -&gt; sessions.GatewayBot:
    route = routes.GET_GATEWAY_BOT.compile()
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_gateway_bot(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_gateway_url" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_gateway_url() -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_gateway_url -- Fetch the gateway url …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_gateway_url"
class='dotted'>fetch_gateway_url</a></code>
</p>
<p>Fetch the gateway url.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint does not require any valid authorization.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1463-L1468" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_gateway_url(self) -&gt; str:
    route = routes.GET_GATEWAY.compile()
    # This doesn&#39;t need authorization.
    raw_response = await self._request(route, no_auth=True)
    response = typing.cast(&#34;typing.Mapping[str, str]&#34;, raw_response)
    return response[&#34;url&#34;]</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_guild(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1708-L1714" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
    route = routes.GET_GUILD.compile(guild=guild)
    query = data_binding.StringMapBuilder()
    query.put(&#34;with_counts&#34;, True)
    raw_response = await self._request(route, query=query)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_rest_guild(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_guild_channels" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_guild_channels(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1807-L1815" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_channels(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[channels.GuildChannel]:
    route = routes.GET_GUILD_CHANNELS.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    channel_sequence = data_binding.cast_json_array(response, self._entity_factory.deserialize_channel)
    # Will always be guild channels unless Discord messes up severely on something!
    return typing.cast(&#34;typing.Sequence[channels.GuildChannel]&#34;, channel_sequence)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_guild_emojis" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_guild_emojis(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1637-L1645" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_emojis(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
    route = routes.GET_GUILD_EMOJIS.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(
        response, self._entity_factory.deserialize_known_custom_emoji, guild_id=snowflakes.Snowflake(guild)
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_guild_invites" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_guild_invites(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2247-L2254" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_invites(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[invites.InviteWithMetadata]:
    route = routes.GET_GUILD_INVITES.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_invite_with_metadata)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_guild_preview" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_guild_preview(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildPreview'>GuildPreview</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1716-L1720" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
    route = routes.GET_GUILD_PREVIEW.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_guild_preview(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_guild_voice_regions(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2238-L2245" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_voice_regions(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[voices.VoiceRegion]:
    route = routes.GET_GUILD_VOICE_REGIONS.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_voice_region)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_guild_webhooks(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_guild_webhooks -- Fetch all guild webhooks …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_webhooks"
class='dotted'>fetch_guild_webhooks</a></code>
</p>
<p>Fetch all guild webhooks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the webhooks for This
may be a <code><a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a></code> or the ID of an
existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The fetched webhooks.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1306-L1313" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_webhooks(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[webhooks.Webhook]:
    route = routes.GET_GUILD_WEBHOOKS.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_webhook)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_integrations" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_integrations(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../guilds.html#hikari.guilds.Integration'>Integration</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2256-L2263" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_integrations(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[guilds.Integration]:
    route = routes.GET_GUILD_INTEGRATIONS.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_integration)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_invite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_invite(
    invite: <a href='../invites.html#hikari.invites.Inviteish'>invites.Inviteish</a>,
) -> <a href='../invites.html#hikari.invites.Invite'>invites.Invite</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_invite -- Fetch an existing invite …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_invite"
class='dotted'>fetch_invite</a></code>
</p>
<p>Fetch an existing invite.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.Inviteish'>Inviteish</a></code></dt>
<dd>The invite to fetch. This may be a <code><a href='../invites.html#hikari.invites.Invite'>Invite</a></code> or
the code of an existing invite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.Invite'>Invite</a></code></dt>
<dd>The requested invite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the invite is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1476-L1482" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_invite(self, invite: invites.Inviteish) -&gt; invites.Invite:
    route = routes.GET_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
    query = data_binding.StringMapBuilder()
    query.put(&#34;with_counts&#34;, True)
    raw_response = await self._request(route, query=query)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_invite(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_member(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../guilds.html#hikari.guilds.Member'>Member</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1972-L1980" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; guilds.Member:
    route = routes.GET_GUILD_MEMBER.compile(guild=guild, user=user)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_members" class="hljs python"><abbr title='A standard Python function.'>def</abbr> fetch_members(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1982-L1987" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_members(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; iterators.LazyIterator[guilds.Member]:
    return special_endpoints.MemberIterator(
        entity_factory=self._entity_factory, request_call=self._request, guild=guild
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_message(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_message -- Fetch a specific message in the given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_message"
class='dotted'>fetch_message</a></code>
</p>
<p>Fetch a specific message in the given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch messages in. This may be a channel object, or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to fetch. This may be a channel object, or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The requested message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the message is not found in the
given text channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L965-L973" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; messages_.Message:
    route = routes.GET_CHANNEL_MESSAGE.compile(channel=channel, message=message)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_messages" class="hljs python"><abbr title='A standard Python function.'>def</abbr> fetch_messages(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    *,
    before: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    after: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    around: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_messages -- Browse the message history for a given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_messages"
class='dotted'>fetch_messages</a></code>
</p>
<p>Browse the message history for a given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch messages in. This may be a channel object, or
the ID of an existing channel.</dd>
<dt><strong><code>before</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages before this snowflakes. If you provide
a datetime object, it will be transformed into a snowflakes. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>after</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages after this snowflakes. If you provide
a datetime object, it will be transformed into a snowflakes. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>around</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages around this snowflakes. If you provide
a datetime object, it will be transformed into a snowflakes. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>An iterator to fetch the messages.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If you specify more than one of <code>before</code>, <code>after</code>, <code><a href='https://docs.python.org/3/about.html'>about</a></code>.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint (other than <code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>) will only
be raised once the result is awaited or interacted with. Invoking
this function itself will not raise anything (other than
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>).</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L922-L963" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_messages(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    *,
    before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[messages_.Message]:
    if undefined.count(before, after, around) &lt; 2:
        raise TypeError(&#34;Expected no kwargs, or maximum of one of &#39;before&#39;, &#39;after&#39;, &#39;around&#39;&#34;)

    timestamp: undefined.UndefinedOr[str]

    if before is not undefined.UNDEFINED:
        direction = &#34;before&#34;
        if isinstance(before, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(before))
        else:
            timestamp = str(int(before))
    elif after is not undefined.UNDEFINED:
        direction = &#34;after&#34;
        if isinstance(after, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(after))
        else:
            timestamp = str(int(after))
    elif around is not undefined.UNDEFINED:
        direction = &#34;around&#34;
        if isinstance(around, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(around))
        else:
            timestamp = str(int(around))
    else:
        direction = &#34;before&#34;
        timestamp = undefined.UNDEFINED

    return special_endpoints.MessageIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        channel=channel,
        direction=direction,
        first_id=timestamp,
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_my_connections" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_my_connections() -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../applications.html#hikari.applications.OwnConnection'>applications.OwnConnection</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_my_connections -- Fetch the token's associated connections …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_my_connections"
class='dotted'>fetch_my_connections</a></code>
</p>
<p>Fetch the token's associated connections.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.OwnConnection'>OwnConnection</a></code></dt>
<dd>The edited token's associated connections.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1515-L1519" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
    route = routes.GET_MY_CONNECTIONS.compile()
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_own_connection)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_my_guilds" class="hljs python"><abbr title='A standard Python function.'>def</abbr> fetch_my_guilds(
    *,
    newest_first: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    start_at: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../applications.html#hikari.applications.OwnGuild'>applications.OwnGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_my_guilds -- Fetch the token's associated guilds …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_my_guilds"
class='dotted'>fetch_my_guilds</a></code>
</p>
<p>Fetch the token's associated guilds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>newest_first</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether to fetch the newest first or the olders first.
Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</dd>
<dt><strong><code>start_at</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>SearchableSnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>If specified, the ID start at. This may be a
<code><a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a></code> or an ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../applications.html#hikari.applications.OwnGuild'>OwnGuild</a>]</code></dt>
<dd>The edited token's associated guilds.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1521-L1539" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_my_guilds(
    self,
    *,
    newest_first: bool = False,
    start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[applications.OwnGuild]:
    if start_at is undefined.UNDEFINED:
        start_at = snowflakes.Snowflake.max() if newest_first else snowflakes.Snowflake.min()
    elif isinstance(start_at, datetime.datetime):
        start_at = snowflakes.Snowflake.from_datetime(start_at)
    else:
        start_at = int(start_at)

    return special_endpoints.OwnGuildIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        newest_first=newest_first,
        first_id=str(start_at),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_my_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_my_user() -> <a href='../users.html#hikari.users.OwnUser'>OwnUser</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_my_user -- Fetch the token's associated user …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_my_user"
class='dotted'>fetch_my_user</a></code>
</p>
<p>Fetch the token's associated user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The token's associated user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1488-L1492" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_my_user(self) -&gt; users.OwnUser:
    route = routes.GET_MY_USER.compile()
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_my_user(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_pins" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_pins(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_pins -- Fetch the pinned messages in this text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_pins"
class='dotted'>fetch_pins</a></code>
</p>
<p>Fetch the pinned messages in this text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch pins from. This may be a channel object, or
the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The pinned messages in this text channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L898-L904" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_pins(
    self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
) -&gt; typing.Sequence[messages_.Message]:
    route = routes.GET_CHANNEL_PINS.compile(channel=channel)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_message)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji" class="hljs python"><abbr title='A standard Python function.'>def</abbr> fetch_reactions_for_emoji(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_reactions_for_emoji -- Fetch reactions for an emoji from a message …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_reactions_for_emoji"
class='dotted'>fetch_reactions_for_emoji</a></code>
</p>
<p>Fetch reactions for an emoji from a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete all reactions from is.
This may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an
existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to delete all reaction from. This may be a
<code><a href='../messages.html#hikari.messages.Message'>Message</a></code> or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to filter reactions by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>An iterator to fetch the users.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1245-L1257" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_reactions_for_emoji(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
    emoji: emojis.Emojiish,
) -&gt; iterators.LazyIterator[users.User]:
    return special_endpoints.ReactorIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        channel=channel,
        message=message,
        emoji=self._transform_emoji_to_url_format(emoji),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_roles" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_roles(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2112-L2121" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_roles(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[guilds.Role]:
    route = routes.GET_GUILD_ROLES.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(
        response, self._entity_factory.deserialize_role, guild_id=snowflakes.Snowflake(guild)
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_user(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../users.html#hikari.users.User'>User</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_user -- Fetch a user …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_user"
class='dotted'>fetch_user</a></code>
</p>
<p>Fetch a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html'>hikari.users.PartialGuild</a>]</code></dt>
<dd>The user to fetch. This can be a <code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code>
or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The requested user</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1593-L1597" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
    route = routes.GET_USER.compile(user=user)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_user(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_vanity_url" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_vanity_url(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../invites.html#hikari.invites.VanityURL'>invites.VanityURL</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2328-L2332" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
    route = routes.GET_GUILD_VANITY_URL.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_vanity_url(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_voice_regions" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_voice_regions() -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_voice_regions -- Fetch available voice regions …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_voice_regions"
class='dotted'>fetch_voice_regions</a></code>
</p>
<p>Fetch available voice regions.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint doesn't return VIP voice regions.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>]</code></dt>
<dd>The available voice regions.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1587-L1591" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
    route = routes.GET_VOICE_REGIONS.compile()
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONArray, raw_response)
    return data_binding.cast_json_array(response, self._entity_factory.deserialize_voice_region)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_webhook(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="fetch_webhook -- Fetch an existing webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_webhook"
class='dotted'>fetch_webhook</a></code>
</p>
<p>Fetch an existing webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to fetch. This may be a <code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code>
or the ID of an existing webhook.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If specified, the webhoook token that will be used to fetch
the webhook instead of the token the client was initialized with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code></dt>
<dd>The requested webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1280-L1295" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.Webhook:
    if token is undefined.UNDEFINED:
        route = routes.GET_WEBHOOK.compile(webhook=webhook)
        no_auth = False
    else:
        route = routes.GET_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
        no_auth = True

    raw_response = await self._request(route, no_auth=no_auth)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_webhook(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.fetch_widget" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> fetch_widget(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2301-L2305" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
    route = routes.GET_GUILD_WIDGET.compile(guild=guild)
    raw_response = await self._request(route)
    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_guild_widget(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.follow_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> follow_channel(
    news_channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>channels.GuildNewsChannel</a>],
    target_channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.ChannelFollow'>ChannelFollow</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="follow_channel -- Follow a news channel to send messages to a target channel …" href="../api/rest.html#hikari.api.rest.RESTClient.follow_channel"
class='dotted'>follow_channel</a></code>
</p>
<p>Follow a news channel to send messages to a target channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>news_channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]</code></dt>
<dd>The object or ID of the news channel to follow.</dd>
<dt><strong><code>target_channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The object or ID of the channel to target.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.ChannelFollow'>ChannelFollow</a></code></dt>
<dd>Information about the new relationship that was made.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you try to follow a channel that's not a news channel or if the
target channel has reached it's webhook limit, which is 10 at the
time of writing.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission in the target
channel or are missing the <code>VIEW_CHANNEL</code> permission in the origin
channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the origin or target channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L797-L811" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def follow_channel(
    self,
    news_channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
    target_channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.ChannelFollow:
    route = routes.POST_CHANNEL_FOLLOWERS.compile(channel=news_channel)
    body = data_binding.JSONObjectBuilder()
    body.put_snowflake(&#34;webhook_channel_id&#34;, target_channel)

    raw_response = await self._request(route, json=body, reason=reason)

    response = typing.cast(data_binding.JSONObject, raw_response)
    return self._entity_factory.deserialize_channel_follow(response)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.guild_builder" class="hljs python"><abbr title='A standard Python function.'>def</abbr> guild_builder(
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
) -> <a href='special_endpoints.html#hikari.impl.special_endpoints.GuildBuilder'>GuildBuilder</a>: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1703-L1706" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
    return special_endpoints.GuildBuilder(
        entity_factory=self._entity_factory, executor=self._executor, request_call=self._request, name=name
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.kick_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> kick_member(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2053-L2061" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def kick_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.kick_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> kick_user(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2053-L2061" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def kick_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.leave_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> leave_guild(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="leave_guild -- Leave a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.leave_guild"
class='dotted'>leave_guild</a></code>
</p>
<p>Leave a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to leave. This may be a <code><a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a></code> or
the ID of an existing guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you own the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1541-L1543" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
    route = routes.DELETE_MY_GUILD.compile(guild=guild)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.pin_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> pin_message(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="pin_message -- Pin an existing message in the given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.pin_message"
class='dotted'>pin_message</a></code>
</p>
<p>Pin an existing message in the given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to pin a message in. This may be a channel object, or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to pin. This may be a message object,
or the ID of an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found, or if the message does not exist in
the given channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L906-L912" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def pin_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; None:
    route = routes.PUT_CHANNEL_PINS.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.remove_role_from_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> remove_role_from_member(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2042-L2051" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def remove_role_from_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.reposition_channels" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> reposition_channels(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    positions: <a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>]],
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L1963-L1970" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def reposition_channels(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels.GuildChannel]],
) -&gt; None:
    route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
    body = [{&#34;id&#34;: str(int(channel)), &#34;position&#34;: pos} for pos, channel in positions.items()]
    await self._request(route, json=body)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.reposition_roles" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> reposition_roles(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    positions: <a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]],
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2151-L2158" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def reposition_roles(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
) -&gt; None:
    route = routes.POST_GUILD_ROLES.compile(guild=guild)
    body = [{&#34;id&#34;: str(int(role)), &#34;position&#34;: pos} for pos, role in positions.items()]
    await self._request(route, json=body)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.sync_integration" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> sync_integration(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    integration: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.Integration'>guilds.Integration</a>],
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2293-L2299" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def sync_integration(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    integration: snowflakes.SnowflakeishOr[guilds.Integration],
) -&gt; None:
    route = routes.POST_GUILD_INTEGRATION_SYNC.compile(guild=guild, integration=integration)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.trigger_typing" class="hljs python"><abbr title='A standard Python function.'>def</abbr> trigger_typing(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
) -> <a href='special_endpoints.html#hikari.impl.special_endpoints.TypingIndicator'>TypingIndicator</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="trigger_typing -- Trigger typing in a text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.trigger_typing"
class='dotted'>trigger_typing</a></code>
</p>
<p>Trigger typing in a text channel.</p>
<p>The result of this call can be awaited to trigger typing once, or
can be used as an async context manager to continually type until the
context manager is left.</p>
<h2 id="examples">Examples</h2>
<pre><code class="py"># Trigger typing just once.
await rest.trigger_typing(channel)

# Trigger typing repeatedly for 1 minute.
async with rest.trigger_typing(channel):
    await asyncio.sleep(60)
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Sending a message to the channel will cause the typing indicator
to disappear until it is re-triggered.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to trigger typing in. This may be a channel object, or
the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a></code></dt>
<dd>A typing indicator to use.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the result
is awaited or interacted with. Invoking this function itself will
not raise any of the above types.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L891-L896" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def trigger_typing(
    self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
) -&gt; special_endpoints.TypingIndicator:
    return special_endpoints.TypingIndicator(
        request_call=self._request, channel=channel, rest_closed_event=self._closed_event
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.unban_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> unban_member(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2082-L2090" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def unban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.unban_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> unban_user(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L2082-L2090" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def unban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.rest.RESTClientImpl.unpin_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> unpin_message(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
class='dotted'>RESTClient</a></code>.<code><a title="unpin_message -- Unpin a given message from a given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.unpin_message"
class='dotted'>unpin_message</a></code>
</p>
<p>Unpin a given message from a given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to unpin a message in. This may be a channel object, or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The message to unpin. This may be a message object, or the ID of an
existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the message is not a pinned message
in the given channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/nekokatt/hikari/blob/9b79731e2cd6e31eb8e2c5fed844a6d4527ac378/hikari/impl/rest.py#L914-L920" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def unpin_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; None:
    route = routes.DELETE_CHANNEL_PIN.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="buckets -- Bucket ratelimiter manager." href="#hikari.impl.rest.RESTClientImpl.buckets" id="hikari.impl.rest.RESTClientImpl.buckets" class='dotted'>buckets</a> : buckets.RESTBucketManager</code></pre>
</dt>
<dd><p>Bucket ratelimiter manager.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="global_rate_limit -- Global ratelimiter." href="#hikari.impl.rest.RESTClientImpl.global_rate_limit" id="hikari.impl.rest.RESTClientImpl.global_rate_limit" class='dotted'>global_rate_limit</a> : rate_limits.ManualRateLimiter</code></pre>
</dt>
<dd><p>Global ratelimiter.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return the HTTP settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.http_settings" id="hikari.impl.rest.RESTClientImpl.http_settings" class='dotted'>http_settings</a> : <a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></pre>
</dt>
<dd><p>Return the HTTP settings in use by this component.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></dt>
<dd>The HTTP settings in use.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- Return the proxy settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.proxy_settings" id="hikari.impl.rest.RESTClientImpl.proxy_settings" class='dotted'>proxy_settings</a> : <a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></pre>
</dt>
<dd><p>Return the proxy settings in use by this component.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></dt>
<dd>The proxy settings in use.</dd>
</dl></dd>
</dl>
<div class="sep"></div>
</dd>
</dl>
</section>
</div>
</div>
</div>
<!-- Search script and dependencies -->
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
window.location.href = url;
};
</script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>